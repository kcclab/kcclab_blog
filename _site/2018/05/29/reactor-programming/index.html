<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>사용하면서 알게 된 Reactor, 예제 코드로 살펴보기 | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="사용하면서 알게 된 Reactor, 예제 코드로 살펴보기" />
<meta name="author" content="john.stonesoup" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Reactor는 Pivotal의 오픈소스 프로젝트로, JVM 위에서 동작하는 논블럭킹 애플리케이션을 만들기 위한 리액티브 라이브러리입니다. Reactor는 RxJava 2와 함께 Reactive Stream의 구현체이기도 하고, Spring Framework 5부터 리액티브 프로그래밍을 위해 지원되는 라이브러리입니다. RxJava에 익숙한 필자가 Reactor를 사용하면서 느낀 것은 RxJava와 많은 공통점이 있으며 큰 차이점이 있다면 Reactor는 최소 Java8에서 동작하며 Java8의 피쳐를 잘 지원한다는 점입니다. 본문에서는 필자가 스프링 프레임워크 WebFlux환경에서 개발을 할 때 Reactor에 대해서 알게 된 점을 공유하고자 합니다. 쉬운 이해를 위해 간단한 자바 애플리케이션 예제 코드를 통해 소개하도록 하겠습니다. 본 예제에서 사용된 자바 버전은 Java8이며, Reactor 버전은 3.1.7 임을 알려드립니다." />
<meta property="og:description" content="Reactor는 Pivotal의 오픈소스 프로젝트로, JVM 위에서 동작하는 논블럭킹 애플리케이션을 만들기 위한 리액티브 라이브러리입니다. Reactor는 RxJava 2와 함께 Reactive Stream의 구현체이기도 하고, Spring Framework 5부터 리액티브 프로그래밍을 위해 지원되는 라이브러리입니다. RxJava에 익숙한 필자가 Reactor를 사용하면서 느낀 것은 RxJava와 많은 공통점이 있으며 큰 차이점이 있다면 Reactor는 최소 Java8에서 동작하며 Java8의 피쳐를 잘 지원한다는 점입니다. 본문에서는 필자가 스프링 프레임워크 WebFlux환경에서 개발을 할 때 Reactor에 대해서 알게 된 점을 공유하고자 합니다. 쉬운 이해를 위해 간단한 자바 애플리케이션 예제 코드를 통해 소개하도록 하겠습니다. 본 예제에서 사용된 자바 버전은 Java8이며, Reactor 버전은 3.1.7 임을 알려드립니다." />
<link rel="canonical" href="http://localhost:4000/2018/05/29/reactor-programming/" />
<meta property="og:url" content="http://localhost:4000/2018/05/29/reactor-programming/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-29T17:00:00+09:00" />
<script type="application/ld+json">
{"datePublished":"2018-05-29T17:00:00+09:00","dateModified":"2018-05-29T17:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/05/29/reactor-programming/"},"url":"http://localhost:4000/2018/05/29/reactor-programming/","author":{"@type":"Person","name":"john.stonesoup"},"description":"Reactor는 Pivotal의 오픈소스 프로젝트로, JVM 위에서 동작하는 논블럭킹 애플리케이션을 만들기 위한 리액티브 라이브러리입니다. Reactor는 RxJava 2와 함께 Reactive Stream의 구현체이기도 하고, Spring Framework 5부터 리액티브 프로그래밍을 위해 지원되는 라이브러리입니다. RxJava에 익숙한 필자가 Reactor를 사용하면서 느낀 것은 RxJava와 많은 공통점이 있으며 큰 차이점이 있다면 Reactor는 최소 Java8에서 동작하며 Java8의 피쳐를 잘 지원한다는 점입니다. 본문에서는 필자가 스프링 프레임워크 WebFlux환경에서 개발을 할 때 Reactor에 대해서 알게 된 점을 공유하고자 합니다. 쉬운 이해를 위해 간단한 자바 애플리케이션 예제 코드를 통해 소개하도록 하겠습니다. 본 예제에서 사용된 자바 버전은 Java8이며, Reactor 버전은 3.1.7 임을 알려드립니다.","@type":"BlogPosting","headline":"사용하면서 알게 된 Reactor, 예제 코드로 살펴보기","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Your awesome title</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        <!--
            my_page.autogen is populated by the pagination logic for all pages
                            that are automatically created by the gem. Check for non-existence to exclude pagination pages from site.pages iterators
          -->
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/index.html">Your awesome title</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">사용하면서 알게 된 Reactor, 예제 코드로 살펴보기</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-05-29T17:00:00+09:00" itemprop="datePublished">May 29, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">john.stonesoup</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://projectreactor.io/">Reactor</a>는 <a href="https://pivotal.io/">Pivotal</a>의 오픈소스
프로젝트로, JVM 위에서 동작하는 논블럭킹 애플리케이션을 만들기 위한 리액티브 라이브러리입니다. Reactor는
<a href="https://github.com/ReactiveX/RxJava/tree/2.x">RxJava 2</a>와 함께 <a href="http://www.reactive-streams.org/">Reactive Stream</a>의 구현체이기도 하고, Spring Framework 5부터
리액티브 프로그래밍을 위해 지원되는 라이브러리입니다. RxJava에 익숙한 필자가 Reactor를 사용하면서 느낀
것은 RxJava와 많은 공통점이 있으며 큰 차이점이 있다면 Reactor는 최소 Java8에서 동작하며 Java8의
피쳐를 잘 지원한다는 점입니다.  <br />
본문에서는 필자가 스프링 프레임워크 WebFlux환경에서 개발을 할 때 Reactor에 대해서 알게 된 점을
공유하고자 합니다. 쉬운 이해를 위해 간단한 자바 애플리케이션 예제 코드를 통해 소개하도록 하겠습니다.
본 예제에서 사용된 자바 버전은 Java8이며, Reactor 버전은 3.1.7 임을 알려드립니다.</p>

<h2 id="mono와-flux">Mono와 Flux</h2>
<p>우선 예제에 들어가기 앞서 Mono와 Flux의 차이점을 알 필요가 있습니다. Mono는 0-1개의 결과만을 처리하기
위한 Reactor의 객체이고, Flux는 0-N개인 여러 개의 결과를 처리하는 객체입니다. Reactor를 사용해
일련의 스트림을 코드로 작성하다 보면 보통 여러 스트림을 하나의 결과를 모아줄 때 Mono를 쓰고, 각각의 Mono를
합쳐서 여러 개의 값을 여러 개의 값을 처리하는 Flux로 표현할 수도 있습니다. 자세한 설명은 Reactor의 <a href="http://projectreactor.io/docs/core/release/reference/#mono">Mono reference</a>와
<a href="http://projectreactor.io/docs/core/release/reference/#flux">Flux reference</a>를 읽어 보시면 됩니다.  <br />
Mono와 Flux모두 <a href="http://www.reactive-streams.org/">Reactive Stream</a>의 <a href="https://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/org/reactivestreams/Publisher.html">Publisher 인터페이스</a>를
구현하고 있으며, Reactor에서 제공하는 풍부한 연산자들(operators)의 조합을 통해 스트림을 표현할 수 있습니다.
예를 들어 Flux에서 하나의 결과로 값을 모아주는 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-java.util.function.BiFunction-">reduce연산자</a>는 Mono를 리턴하고, Mono에서 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-">flatMapMany</a>라는 연산자를 사용하면 하나의 값으로부터 여러 개의 값을 취급하는 Flux를 리턴할 수 있습니다. 그리고 <code class="highlighter-rouge">Publisher</code>인터페이스에 정의된
<code class="highlighter-rouge">subscribe</code>메서드를 호출함으로써 <code class="highlighter-rouge">Mono</code>나 <code class="highlighter-rouge">Flux</code>가 동작하도록 할 수 있습니다. 자세한 내용은 예제 코드를
통해 다루도록 하겠습니다.</p>

<h2 id="하나의-스트림에서-여러-스트림으로">하나의 스트림에서 여러 스트림으로</h2>
<p>여기서는 하나의 스트림에서 여러 개의 스트림으로 갈라질 때 <code class="highlighter-rouge">Flux</code>와 <code class="highlighter-rouge">Mono</code>를 어떻게 적절히 섞어서 사용했는지
예제를 통해 보도록 하겠습니다.</p>

<h3 id="과일바구니-예제">과일바구니 예제</h3>
<p>여기서 사용할 예제는 과일바구니 예제입니다. basket1부터 basket3까지 3개의 과일바구니가 있으며, 과일바구니
안에는 과일을 중복해서 넣을 수 있습니다. 그리고 이 바구니를 List로 가지는 <code class="highlighter-rouge">baskets</code>가 있습니다.
<code class="highlighter-rouge">Flux.fromIterable</code>에 <code class="highlighter-rouge">Iterable</code> type의 인자를 넘기면 이 <code class="highlighter-rouge">Iterable</code>을 <code class="highlighter-rouge">Flux</code>로 변환해줍니다.
이러한 예제를 만든 이유는 스프링에서 <code class="highlighter-rouge">WebClient</code>를 이용하여 특정 HTTP API를 호출하고 받은 JSON 응답에 여러
배열이 중첩되어 있고, 여기서 또 다른 API를 호출하거나 데이터를 조작하는 경우가 있었습니다. <br />
처음엔 API 호출을 몇 번하고 원하는 데이터로 조작하고자 하는 필요에서 시작하였지만, 받은 데이터를 막상
적절한 연산자의 조합으로 하려고 접근하다 보면 어려워지고, 어떻게 하면 쉽게 풀 수 있을까 생각해보았습니다.
그리고 간단한 예제를 만들어 연습해보는 것이 좋겠다는 생각이 들었습니다. 따라서 이러한 연습을 위해 여기서는
과일바구니를 표현하는 리스트를 만들어 시작을 해보도록 하겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">basket1</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">"kiwi"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"kiwi"</span><span class="o">});</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">basket2</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">"banana"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"kiwi"</span><span class="o">});</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">basket3</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">"strawberry"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"grape"</span><span class="o">,</span> <span class="s">"strawberry"</span><span class="o">});</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">baskets</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">basket1</span><span class="o">,</span> <span class="n">basket2</span><span class="o">,</span> <span class="n">basket3</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">basketFlux</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">baskets</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="바구니-속-과일-종류중복-없이-및-각-종류별-개수-나누기">바구니 속 과일 종류(중복 없이) 및 각 종류별 개수 나누기</h3>
<p><code class="highlighter-rouge">basketFlux</code>로부터 중복 없이 각 과일 종류를 나열하고, 각 과일이 몇 개씩 들어있는지 각 바구니마다 출력하는
코드를 작성해보도록 하겠습니다. 단순히 <code class="highlighter-rouge">Reactor</code>사용 없이 <code class="highlighter-rouge">Java</code>에 있는 방법만으로 함수형 프로그래밍도 아닌
절차 지향적으로 생각해보면 어렵지 않습니다. baskets를 for each loop로 돌면서 <code class="highlighter-rouge">Set</code>에 담을 수도 있고,
각 과일의 개수는 <code class="highlighter-rouge">Set</code>에 처음으로 들어가는 경우 <code class="highlighter-rouge">Map</code>에 key값으로 1 값을 갖게 만들고, 그 외의 경우는
1씩 증가시키는 방법으로 과일의 개수를 셀 수 있습니다. <br />
그렇다면 <code class="highlighter-rouge">basketFlux</code>에서 연산자들의 조합으로 어떻게 이 2가지 과제를 할 수 있을까요? 우선 이 기능을
추상화한 연산자를 찾아볼 수 있습니다. 중복 없이 값을 처리하는 연산자로 <code class="highlighter-rouge">distinct</code>가 있고, 각 <code class="highlighter-rouge">key</code>별로
스트림을 관리하기 원한다면 <code class="highlighter-rouge">key</code>를 기준으로 Flux로 그룹을 묶을 수 있는 <code class="highlighter-rouge">groupBy</code>가 있습니다. 그리고
스트림에서 내려주는 값의 개수를 셀 수 있는 <code class="highlighter-rouge">count</code>라는 연산자도 있습니다. 그런데 이것들을 하려면 <code class="highlighter-rouge">basketFlux</code>로부터
각각의 바구니들을 꺼내야 합니다. 이렇게 값을 꺼내서 새로운 <code class="highlighter-rouge">Publisher</code>로 바꿔줄 수 있는 연산자로는
대표적으로 <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">flatMapSequential</code>, <code class="highlighter-rouge">concatMap</code>이 있습니다. <code class="highlighter-rouge">flatMap</code>은 리턴하는
<code class="highlighter-rouge">Publisher</code>가 비동기로 동작할 때 순서를 보장하지 않으므로, 순서 보장을 하려면 <code class="highlighter-rouge">flatMapSequential</code>
또는 <code class="highlighter-rouge">concatMap</code>을 사용해야 하는데, 여기서는 <code class="highlighter-rouge">concatMap</code>을 사용하도록 하겠습니다. <code class="highlighter-rouge">flatMapSequential</code>과
<code class="highlighter-rouge">concatMap</code>의 차이는 <code class="highlighter-rouge">concatMap</code>은 인자로 지정된 함수에서 리턴하는 <code class="highlighter-rouge">Publisher</code>의 스트림이 다
끝난 후에 그다음 넘어오는 값의 <code class="highlighter-rouge">Publisher</code>스트림을 처리하지만, <code class="highlighter-rouge">flatMapSequential</code>은 일단 오는 대로 구독하고 결과는 순서에 맞게 리턴하는 역할을 해서, 비동기 환경에서 동시성을 지원하면서도 순서를 보장할 때 쓰이는 것이 차이점입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">)</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                    <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}});</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
    <span class="c1">// return ???</span>
<span class="o">});</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>라는 이름으로 앞서 소개한 연산자들로 조합을 했습니다.  <br />
과일의 중복이 없도록 모으는 <code class="highlighter-rouge">distinctFruits</code>에서는 List로 변환하기 위해 <code class="highlighter-rouge">Flux</code>에서 제공하는
<code class="highlighter-rouge">collectList</code>를 이용했습니다. 이렇게 하면 <code class="highlighter-rouge">Flux</code>에서 넘어오는 각각의 항목들을 하나의 리스트로 모아주는
<code class="highlighter-rouge">Mono</code>로 변환할 수 있습니다. countFruitsMono에서는 각 과일의 개수를 key, value를 갖는 <code class="highlighter-rouge">Map</code>
(자료구조 interface Map)으로 모으기 위해서 <code class="highlighter-rouge">reduce</code>를 이용해서 합쳤습니다. 순서를 보장하기 위해
<code class="highlighter-rouge">concatMap</code>과 <code class="highlighter-rouge">LinkedHashMap</code>을 사용했습니다. 이렇게 하면 순서대로 넘어온 각 과일의 개수를
순서대로 <code class="highlighter-rouge">Map</code>에 순서에 따라 모을 수 있습니다. <br />
이렇게 만들어 놓으니 이제 이 둘을 각각 합쳐서 하나의 스트림으로 리턴을 해줘야 합니다. 리턴 부분은 아직
물음표로 주석처리를 해두었습니다. 이렇게 2개의 스트림을 하나의 객체를 리턴하는 <code class="highlighter-rouge">Publisher</code>로 합쳐주는
연산자로는 <code class="highlighter-rouge">Flux.zip</code>이 있습니다. 이것을 합쳐줄 객체를 만들기 위해 <code class="highlighter-rouge">FruitInfo</code>라는 클래스를 정의하고
<code class="highlighter-rouge">zip</code>연산자를 사용해보도록 하겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/zip.png" alt="zip연산자 마블다이어그램" /></p>

<p><code class="highlighter-rouge">FruitInfo 클래스</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitInfo</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">distinctFruits</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">countFruits</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">FruitInfo</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">distinctFruits</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">countFruits</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">distinctFruits</span> <span class="o">=</span> <span class="n">distinctFruits</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">countFruits</span> <span class="o">=</span> <span class="n">countFruits</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="n">FruitInfo</span> <span class="n">fruitInfo</span> <span class="o">=</span> <span class="o">(</span><span class="n">FruitInfo</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">distinctFruits</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="o">!</span><span class="n">distinctFruits</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">fruitInfo</span><span class="o">.</span><span class="na">distinctFruits</span><span class="o">)</span> <span class="o">:</span> <span class="n">fruitInfo</span><span class="o">.</span><span class="na">distinctFruits</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">countFruits</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">countFruits</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">fruitInfo</span><span class="o">.</span><span class="na">countFruits</span><span class="o">)</span> <span class="o">:</span> <span class="n">fruitInfo</span><span class="o">.</span><span class="na">countFruits</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">distinctFruits</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">distinctFruits</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">countFruits</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">countFruits</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"FruitInfo{"</span> <span class="o">+</span>
                <span class="s">"distinctFruits="</span> <span class="o">+</span> <span class="n">distinctFruits</span> <span class="o">+</span>
                <span class="s">", countFruits="</span> <span class="o">+</span> <span class="n">countFruits</span> <span class="o">+</span>
                <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">zip연산자로 합친 예제</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">)</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                    <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>결과</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
FruitInfo{distinctFruits=[banana, lemon, kiwi], countFruits={banana=1, lemon=2, kiwi=1}}
FruitInfo{distinctFruits=[strawberry, orange, lemon, grape], countFruits={strawberry=2, orange=1, lemon=1, grape=1}}
</code></pre></div></div>

<p><code class="highlighter-rouge">distinct</code> 된 리스트와 각 과일의 개수를 묶은 리스트를 하나의 리스트로 묶어서 각각 출력하는 것을 확인할 수
있습니다. 그런데 이런 식의 방식은 너무 비효율적입니다. <code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>모두
<code class="highlighter-rouge">Flux.fromIterable(basket)</code>로부터 시작해서 각각 <code class="highlighter-rouge">basket</code>을 독립적으로 순회합니다. 절차 지향으로
생각하면 하나의 for each loop 안에서 2가지를 한 번에 해결할 수 있는데 여기서는 총 2번 basket을 순회하고,
특별히 스레드를 지정하지 않았기 때문에 동기, 블록킹 방식으로 동작합니다. 논 블록킹 라이브러리의 장점을 전혀
살릴 수 없고, 효율성도 떨어집니다. 단순히 Reactor에서 제공하는 연산자들의 조합의 코드일 뿐입니다.  <br />
그래서 비동기 논 블록킹으로 동시성도 살리면서, 순차적으로 basket을 두 번 순회하지 않는 방법을 다음 코드에서
다뤄보고자 합니다.</p>

<h3 id="병렬로-두-스트림-합쳐보기">병렬로 두 스트림 합쳐보기</h3>
<p><code class="highlighter-rouge">Reactor</code>나 <code class="highlighter-rouge">RxJava</code> 모두 동시성 지원을 위해 <code class="highlighter-rouge">Scheduler</code>를 제공합니다. 적절한 <code class="highlighter-rouge">Scheduler</code>를
적절한 위치에 지정함으로써 동시성과 실행 순서를 적절히 관리할 수 있습니다. 기본적으로 스케줄러를 지정하지
않고 사용하는 연산자가 특정한 스케줄러에서 동작하지 않는다면, Reactor의 Flux나 Mono는 구독할 때 현재
스레드에서 동작합니다. 따라서 위의 코드도 로그를 찍어봄으로써 스레드를 확인해보면 모든 코드가
<code class="highlighter-rouge">main thread</code>에서 동기로 실행되는 것을 확인할 수 있습니다. 스프링 프레임워크 5부터 제공하는 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client">WebClient</a>를 사용하면 다른 스레드로 이미 바뀌어서 비동기로 동작하겠지만, 해당 스레드 안에서도 몇몇 스트림은 병렬로 실행시키고자
할 필요가 있을 수 있습니다. 그렇다면 어떻게 스케줄러를 지정하여 1) 과일의 종류를 뽑아내는 것과
2) 과일의 개수를 뽑아내는 이 2가지 작업을 병렬로 실행할 수 있을지 알아보도록 하겠습니다.</p>

<h4 id="병렬-스케줄러-schedulersparallel">병렬 스케줄러 (Schedulers.parallel())</h4>
<p>Reactor의 <a href="http://projectreactor.io/docs/core/release/reference/#schedulers">스케줄러 관련 문서</a>를
보면 기본적으로 제공하는 몇 가지 스케줄러에 대한 설명이 있습니다. 여기서는 병렬로 여러 개를 실행시키기 위해
<code class="highlighter-rouge">Schedulers.parallel()</code>을 사용하도록 했는데, 이 스케줄러는 병렬 실행을 위해 CPU 코어 개수만큼
워커를 만들어 병렬로 실행을 지원하는 스케줄러 입니다. <code class="highlighter-rouge">RxJava</code>에서는 <code class="highlighter-rouge">Schedulers.computation()</code>이
해당 스케줄러에 해당되는 것으로 알고 있습니다. 필자의 머신에서는 쿼드코어에 하이퍼스레딩의 영향으로 최대
8개의 스레드로 해당 스케줄러가 동작하는 것을 확인할 수 있었습니다.</p>

<h4 id="subscribeon으로-스케줄러-전환하기">subscribeOn으로 스케줄러 전환하기</h4>
<p><code class="highlighter-rouge">subscribeOn</code>연산자는 해당 스트림을 구독할 때 동작하는 스케줄러를 지정할 수 있습니다. 여기서 <code class="highlighter-rouge">distinctFruits</code>와
<code class="highlighter-rouge">countFruitsMono</code>가 각각 병렬로 동작하길 원하므로 <code class="highlighter-rouge">subscribeOn(Schedulers.parallel())</code>을
각각 추가하여 실행시켜 보았습니다. 그런데 이 자바 애플리케이션은 아무 결과도 확인 못하고 끝나 버립니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">().</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">)</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                    <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
            <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>왜냐하면 <code class="highlighter-rouge">parallel스케줄러</code>는 <code class="highlighter-rouge">데몬스레드(Deamon Thread)</code>인데 이 애플리케이션이 처음 동작하는
<code class="highlighter-rouge">main thread</code>는 데몬스레드가 아닌 <code class="highlighter-rouge">비-데몬스레드(Non-Deamon Thread)</code>이기 때문에 <code class="highlighter-rouge">main</code>메서드가
끝나버리며 아무런 비-데몬스레드가 남지 않아 종료되기 때문입니다. 종료되지 않고 계속 동작해야 하는 서버 환경의
애플리케이션에서는 괜찮겠지만, 본 애플리케이션은 <code class="highlighter-rouge">main</code>메서드가 끝난 후 비-데몬스레드가 하나도 남아있지 않아
종료됩니다. 이를 방지하기 위해  <code class="highlighter-rouge">CountDownLatch</code>를 이용하여 <code class="highlighter-rouge">await()</code>으로 애플리케이션이 종료되지
않게 <code class="highlighter-rouge">main</code>스레드가 동작이 끝날 때까지 기다리도록 하겠습니다. 위의 스트림이 정상적으로 또는 에러가 나서
종료한 경우에 <code class="highlighter-rouge">countDown</code>메서드를 호출하여 더 이상 기다리지 않고 종료되도록 하겠습니다. 혹시 모르게
오랫동안 기다리는 경우를 막기 위해 <code class="highlighter-rouge">await(2, TimeUnit.SECONDS)</code>으로 2초 정도의 timeout을 두도록
했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// ... 생략</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span>  <span class="c1">// 값이 넘어올 때 호출 됨, onNext(T)</span>
        <span class="n">error</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">error</span><span class="o">);</span>
            <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
        <span class="o">},</span> <span class="c1">// 에러 발생시 출력하고 countDown, onError(Throwable)</span>
        <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"complete"</span><span class="o">);</span>
            <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
        <span class="o">}</span> <span class="c1">// 정상적 종료시 countDown, onComplete()</span>
<span class="o">);</span>
<span class="n">countDownLatch</span><span class="o">.</span><span class="na">await</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>

<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
FruitInfo{distinctFruits=[banana, lemon, kiwi], countFruits={banana=1, lemon=2, kiwi=1}}
FruitInfo{distinctFruits=[strawberry, orange, lemon, grape], countFruits={strawberry=2, orange=1, lemon=1, grape=1}}
complete
</code></pre></div></div>
<p>결과가 잘 나오는 것을 확인할 수 있습니다. 병렬로 실행되는지 확인하기 위해 <code class="highlighter-rouge">distinctFruits</code>와
<code class="highlighter-rouge">countFruitsMono</code>의 각각의 시작점 <code class="highlighter-rouge">Flux.fromIterable(basket)</code>에 <code class="highlighter-rouge">log()</code>라는 메서드를
추가하도록 하겠습니다. 그러면 <code class="highlighter-rouge">log()</code>를 호출한 지점 위에서 넘어오는 값을 로그로 확인하며 디버깅하기
좋습니다. Reactor에서 유용한 메서드 중 하나입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">().</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">()</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                    <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
            <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span>  <span class="c1">// 값이 넘어올 때 호출 됨, onNext(T)</span>
    <span class="n">error</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">error</span><span class="o">);</span>
        <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
    <span class="o">},</span> <span class="c1">// 에러 발생시 출력하고 countDown, onError(Throwable)</span>
    <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"complete"</span><span class="o">);</span>
        <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
    <span class="o">}</span> <span class="c1">// 정상적 종료시 countDown, onComplete()</span>
<span class="o">);</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] (parallel-1) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscriptionConditional)
[ INFO] (parallel-2) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)
[ INFO] (parallel-1) | request(unbounded)
[ INFO] (parallel-2) | request(256)
[ INFO] (parallel-1) | onNext(kiwi)
[ INFO] (parallel-2) | onNext(kiwi)
[ INFO] (parallel-1) | onNext(orange)
[ INFO] (parallel-1) | onNext(lemon)
[ INFO] (parallel-1) | onNext(orange)
[ INFO] (parallel-1) | onNext(lemon)
[ INFO] (parallel-1) | onNext(kiwi)
[ INFO] (parallel-1) | onComplete()
[ INFO] (parallel-2) | request(1)
[ INFO] (parallel-2) | onNext(orange)
[ INFO] (parallel-2) | onNext(lemon)
[ INFO] (parallel-2) | onNext(orange)
[ INFO] (parallel-2) | onNext(lemon)
[ INFO] (parallel-2) | onNext(kiwi)
[ INFO] (parallel-2) | request(1)
[ INFO] (parallel-2) | onComplete()
[ INFO] (parallel-2) | request(2)
FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
[ INFO] (parallel-2) | cancel()
[ INFO] (parallel-2) | cancel()
[ INFO] (parallel-3) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscriptionConditional)
[ INFO] (parallel-4) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)
[ INFO] (parallel-3) | request(unbounded)
[ INFO] (parallel-4) | request(256)
[ INFO] (parallel-3) | onNext(banana)
[ INFO] (parallel-4) | onNext(banana)
[ INFO] (parallel-3) | onNext(lemon)
[ INFO] (parallel-4) | request(1)
[ INFO] (parallel-3) | onNext(lemon)
[ INFO] (parallel-4) | onNext(lemon)
[ INFO] (parallel-3) | onNext(kiwi)
[ INFO] (parallel-4) | onNext(lemon)
[ INFO] (parallel-3) | onComplete()
[ INFO] (parallel-4) | onNext(kiwi)
[ INFO] (parallel-4) | onComplete()
[ INFO] (parallel-4) | request(2)
[ INFO] (parallel-4) | request(1)
FruitInfo{distinctFruits=[banana, lemon, kiwi], countFruits={banana=1, lemon=2, kiwi=1}}
... 이하 생략 ...
</code></pre></div></div>
<p>처음엔 <code class="highlighter-rouge">parallel-1</code>과 <code class="highlighter-rouge">parallel-2</code>이 같이 동작하고, 그다음 순서로 <code class="highlighter-rouge">parallel-3</code>과
<code class="highlighter-rouge">parallel-4</code>이 같이 동작하는 것을 로그를 통해 확인할 수 있습니다.</p>

<h3 id="basket당-하나의-스트림만-공유하며-과일종류와-개수-뽑아내기">basket당 하나의 스트림만 공유하며 과일종류와 개수 뽑아내기</h3>
<p>지금까지 진행해온 과정에서 아쉬운 점을 좀 더 개선해보고자 합니다. <code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>
모두 <code class="highlighter-rouge">Flux.fromIterable(basket)</code>에서 출발하기 때문에 병렬로 동작해도 <code class="highlighter-rouge">baskets</code>를 각각 순회하여
중복되는 동작이라는 점은 처음의 예제와 다를 게 없습니다. 또한 몇 개 안 되는 데이터를 각각 병렬로 처리하는 것은
스레드를 생성하고 컨텍스트 스위칭을 하는 비용을 생각하면 배보다 배꼽이 클 수도 있습니다. <code class="highlighter-rouge">baskets</code>을
순회하는 공통 작업을 하나의 스트림에서 하는 방법은 없을까요? 먼저 관련된 배경지식을 다루고 그 방법을 함께
살펴보도록 하겠습니다.</p>

<h4 id="hot-cold-개념">Hot, Cold 개념</h4>
<p>Hot과 Cold 개념은 RxJava에도 있는 개념으로 Reactor의 Hot, Cold 개념은 <a href="http://projectreactor.io/docs/core/snapshot/reference/#reactor.hotCold">공식문서 Hot vs Cold</a>를
통해서 확인하실 수 있습니다.  <br />
간단히 설명하면 <code class="highlighter-rouge">Cold</code>는 각 <code class="highlighter-rouge">Flux</code>나 <code class="highlighter-rouge">Mono</code>를 <code class="highlighter-rouge">subscribe</code> 할 때마다 매번 독립적으로 새로 데이터를
생성해서 동작합니다. 즉, <code class="highlighter-rouge">subscribe</code>호출 전까지 아무런 동작도 하지 않고, <code class="highlighter-rouge">subscribe</code>를 호출하면
새로운 데이터를 생성합니다. 기본적으로 특별하게 <code class="highlighter-rouge">Hot</code>을 취급하는 연산자가 아닌 이상 <code class="highlighter-rouge">Flux</code>나 <code class="highlighter-rouge">Mono</code>는
<code class="highlighter-rouge">Cold</code>로 동작합니다. 따라서 지금까지 예제는 <code class="highlighter-rouge">basket</code>으로부터 값을 꺼내어 각각 따로 새로운 데이터를
생성하기 때문에 각각 중복된 작업을 새로 시작하게 동작합니다.  <br />
그러나 <code class="highlighter-rouge">Hot</code>은 구독하기 전부터 데이터의 스트림이 동작할 수 있습니다. 예를 들어서 마우스 클릭이나 키보드
입력 같은 이벤트 성은 구독여부와 상관없이 발생하고 있다가 이 이벤트를 구독하는 여러 구독자가 붙으면 해당
이벤트가 발생할 때 모두 동일한 값을 전달받을 수 있습니다. 즉, <code class="highlighter-rouge">Hot</code>에 해당하는 스트림을 여러 곳에서
구독을 하면 현재 스트림에서 나오는 값을 구독하는 구독자들은 동일하게 받을 수 있습니다.   <br />
여기서 주목할 점은 <code class="highlighter-rouge">Cold</code>를 <code class="highlighter-rouge">Hot</code>으로 바꿀 수 있는 연산자가 있다는 것입니다. 처음 <code class="highlighter-rouge">Hot</code>에 대해서
예제를 든 마우스클릭이나 키보드입력같은 이벤트를 떠올리면 쉽게 상상이 안되는데요. <code class="highlighter-rouge">Cold</code>는 구독을 하면
값을 생성하기 시작합니다. 그러나 <code class="highlighter-rouge">Cold</code>를 <code class="highlighter-rouge">Hot</code>으로 바꾸면 구독여부와 상관없이 값을 생성 안 하다가
특정 시점에 값을 생성하도록 제어하여 구독하는 구독자(Subscriber)들이 동일한 값을 받을 수 있도록 할 수
있습니다. 이에 대해 알아보겠습니다.</p>

<h4 id="connectable-flux">Connectable Flux</h4>
<p><a href="http://projectreactor.io/docs/core/snapshot/reference/#advanced-broadcast-multiple-subscribers-connectableflux">Connectable Flux</a>는
<code class="highlighter-rouge">Cold</code>에서 <code class="highlighter-rouge">Hot</code>으로 바꾸기 위해서는 <code class="highlighter-rouge">Connectable Flux</code>로 변환하는 과정이 필요합니다. 공식문서에
설명되어 있듯 기본적으로 <code class="highlighter-rouge">publish</code>라는 연산자를 호출하면 바꿀 수 있습니다. 이렇게 변환된 Flux에서
<code class="highlighter-rouge">connect()</code>라는 메서드를 호출할 수 있는데, 이 메서드가 여러 구독자들이 <code class="highlighter-rouge">Connectable Flux</code>를
구독한 후 값을 생성하여 각 구독자에게 보내기 시작하게 하는 메서드입니다. 즉, 우리의 예제에서는 <code class="highlighter-rouge">distinctFruits</code>와
<code class="highlighter-rouge">countFruitsMono</code>가 구독을 모두 완료한 후에 <code class="highlighter-rouge">connect()</code>를 호출할 수 있게 해주면 됩니다. 어떻게
할 수 있을까요? 다행히 Reactor에서는 <code class="highlighter-rouge">autoConnect</code>나 <code class="highlighter-rouge">refCount</code>에 인자 값으로 최소 구독하는 구독자의
개수를 지정해서 이 개수가 충족되면 자동으로 값을 생성할 수 있게 연산자를 제공합니다. 2개의 차이점이 있다면
<code class="highlighter-rouge">autoConnect</code>는 이름 그대로 최소 구독 개수를 만족하면 자동으로 <code class="highlighter-rouge">connect()</code>를 호출하는 역할만 하고,
<code class="highlighter-rouge">refCount</code>는 <code class="highlighter-rouge">autoConnect</code>가 하는 일에 더해서 구독하고 있는 구독자의 개수를 세다가 하나도 구독하는
곳이 없으면 기존 소스의 스트림도 구독을 해제하는 역할을 합니다. <code class="highlighter-rouge">interval</code>처럼 무한히 일정 간격으로
값이 나오는 스트림을 <code class="highlighter-rouge">Hot</code>으로 바꾼다면 <code class="highlighter-rouge">refCount</code>를 고려해 볼 수 있을 것입니다. 호출되는 소스가
무한으로 값을 생성한다면 더 이상 구독을 안 할 때 해제하게 <code class="highlighter-rouge">refCount</code>를 고려해볼 수 있지만, 우리는 제한된 개수의
데이터만 다 다루면 알아서 완료가 되기 때문에 <code class="highlighter-rouge">autoConnect</code>로 충분하다고 생각합니다. 참고로 여기서
소개한 2개의 연산자는 인자 값을 없을 경우 최초 구독이 발생할 때 <code class="highlighter-rouge">connect()</code>를 호출하도록 동작하고,
<code class="highlighter-rouge">publish().refCount()</code>를 하나의 연산자로 추상화한 연산자를 <code class="highlighter-rouge">share()</code>라고 합니다. 그 밖에
<code class="highlighter-rouge">RxJava</code>의 <code class="highlighter-rouge">ConnectableFlowable</code>도 동일한 기능을 제공하는 것을 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/flowables/ConnectableFlowable.html">문서</a>를
통해 확인할 수 있었습니다.</p>

<h4 id="2개-구독자가-구독하면-자동으로-동작하게-hot-flux-만들기">2개 구독자가 구독하면 자동으로 동작하게 Hot Flux 만들기</h4>
<p>이제 코드로 공통적으로 사용하는 <code class="highlighter-rouge">Flux.fromIterable(basket)</code>을 <code class="highlighter-rouge">Hot</code>으로 만들어보도록 하겠습니다.  <br />
설명에서 소개한 바와 같이 <code class="highlighter-rouge">publish().autoConnect(2)</code>를 사용하도록 하겠습니다. 이렇게 하면 <code class="highlighter-rouge">Hot</code>으로
변환된 <code class="highlighter-rouge">ConnectableFlux</code>를 최소 2개의 구독자가 구독을 하면 자동으로 구독하는 <code class="highlighter-rouge">Flux</code>를 리턴합니다.
이를 소스코드에서는 <code class="highlighter-rouge">source</code>라는 변수에 지정하고, <code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>모두
<code class="highlighter-rouge">source</code>를 공통으로 쓰도록 했습니다. <code class="highlighter-rouge">Flux.fromIterable(basket)</code> 뒤에 <code class="highlighter-rouge">log()</code>는 그대로 두었습니다. <br />
한 번만 값이 나오나 확인하기 위함입니다. 추가로  <code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>에서
<code class="highlighter-rouge">subscribeOn</code>은 제거했습니다. 굳이 몇 개 안 되는 데이터를 병렬로 돌릴 필요가 없어 보였고, 하나의 스레드에서
<code class="highlighter-rouge">Flux.fromIterable(basket)</code>가 한 번만 동작하면서 2가지 스트림으로 동작할 수 있음을 보여주기 위함입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">publish</span><span class="o">().</span><span class="na">autoConnect</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">source</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                        <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                        <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                    <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}});</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span>  <span class="c1">// 값이 넘어올 때 호출 됨, onNext(T)</span>
    <span class="n">error</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">error</span><span class="o">);</span>
        <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
    <span class="o">},</span> <span class="c1">// 에러 발생시 출력하고 countDown, onError(Throwable)</span>
    <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"complete"</span><span class="o">);</span>
        <span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
    <span class="o">}</span> <span class="c1">// 정상적 종료시 countDown, onComplete()</span>
<span class="o">);</span>
</code></pre></div></div>

<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] (main) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)
[ INFO] (main) | onNext(kiwi)
[ INFO] (main) | onNext(orange)
[ INFO] (main) | onNext(lemon)
[ INFO] (main) | onNext(orange)
[ INFO] (main) | onNext(lemon)
[ INFO] (main) | onNext(kiwi)
[ INFO] (main) | onComplete()
FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
...이하생략
</code></pre></div></div>

<p>이하 결과를 생략했지만 모두 <code class="highlighter-rouge">main</code>스레드에서 값이 잘 나오는 것을 확인할 수 있습니다. 여기서는 동일한
스레드이기 때문에 <code class="highlighter-rouge">countDownLatch</code>도 필요가 없습니다. 두 군데서 구독할 때만 값이 나오는지 확인하기 위해
<code class="highlighter-rouge">zip</code>에서 쓰이는 <code class="highlighter-rouge">distinctFruits</code>의 <code class="highlighter-rouge">source</code>를 <code class="highlighter-rouge">Flux.fromIterable(basket)</code>로 바꿔서
<code class="highlighter-rouge">source</code>가 한 번만 구독되도록 해보겠습니다.</p>

<p><code class="highlighter-rouge">source를 한 곳 countFruitsMono에서만 구독할 때 예제</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">publish</span><span class="o">().</span><span class="na">autoConnect</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span>
    <span class="c1">//생략...</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="cm">/* 생략.. */</span><span class="o">);</span>
</code></pre></div></div>

<p>구독한 후 아무 값도 나오지 않습니다. <code class="highlighter-rouge">complete</code>도 불리지 않는 것을 확인할 수 있습니다.</p>

<h4 id="hot-이후에-각-스트림만-비동기로-처리하기">Hot 이후에 각 스트림만 비동기로 처리하기</h4>
<p>위의 예제에서는 몇 개 안 되는 데이터라 같은 스레드에서 동기로 실행시켰지만, 데이터가 많아지거나 현재 스레드가
다른 일을 하게 하기 위해서 <code class="highlighter-rouge">distinct</code>나 <code class="highlighter-rouge">groupBy</code> <code class="highlighter-rouge">count</code> 등의 연산을 하는 지점은 각각 비동기로
처리하고자 하는 필요가 생길 수도 있습니다. 그러나 앞서 소개한 <code class="highlighter-rouge">subscribeOn</code>은 이런 경우 적절하지 않습니다. <br />
<code class="highlighter-rouge">subscribeOn</code>을 호출한 객체를 구독할 때는 해당 스트림 전체가 해당 스케줄러로 다 바뀌기 때문에, <code class="highlighter-rouge">Hot</code>인
<code class="highlighter-rouge">source</code>도 2개의 구독자가 구독을 하면 <code class="highlighter-rouge">subscribeOn</code>이 지정한 스레드에서 실행되게 되며, 그러면
<code class="highlighter-rouge">distinct</code>와 <code class="highlighter-rouge">count</code>로 갈라져 나오는 부분도 같은 스레드에서 실행되기 때문입니다. 이를 확인하기 위해
기존의 예제에서 <code class="highlighter-rouge">distinctFruits</code>와 <code class="highlighter-rouge">countFruitsMono</code>에 각각 <code class="highlighter-rouge">subscribeOn(Schedulers.parallel())</code>을
붙여서 실행해보겠습니다. 이때 각각 어느 스레드에서 동작하는지 확인하기 위해 <code class="highlighter-rouge">log()</code>를 붙였습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
   <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">publish</span><span class="o">().</span><span class="na">autoConnect</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
   <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
   <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">source</span>
           <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
           <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                   <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                       <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                       <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                       <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                   <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
           <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
           <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
               <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
               <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
           <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
           <span class="o">.</span><span class="na">log</span><span class="o">()</span>
           <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">());</span>
   <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="cm">/* 생략.. */</span><span class="o">);</span>
</code></pre></div></div>

<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] (parallel-1) | onSubscribe([Fuseable] MonoCollectList.MonoBufferAllSubscriber)
[ INFO] (parallel-2) | onSubscribe([Fuseable] MonoReduce.ReduceSubscriber)
[ INFO] (parallel-1) | request(32)
[ INFO] (parallel-2) | request(32)
[ INFO] (parallel-1) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)
[ INFO] (parallel-1) | onNext(kiwi)
[ INFO] (parallel-1) | onNext(orange)
[ INFO] (parallel-1) | onNext(lemon)
[ INFO] (parallel-1) | onNext(orange)
[ INFO] (parallel-1) | onNext(lemon)
[ INFO] (parallel-1) | onNext(kiwi)
[ INFO] (parallel-1) | onComplete()
[ INFO] (parallel-1) | onNext([kiwi, orange, lemon])
[ INFO] (parallel-1) | onComplete()
[ INFO] (parallel-1) | onNext({kiwi=2, orange=2, lemon=2})
FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
</code></pre></div></div>

<p>처음엔 <code class="highlighter-rouge">parallel-1</code>과 <code class="highlighter-rouge">parallel-2</code>로 동작하는 듯했다가 결국 <code class="highlighter-rouge">source</code>는 <code class="highlighter-rouge">parallel-1</code>에서 실행됩니다.
2개의 구독자가 구독을 한 후 <code class="highlighter-rouge">source</code>가 <code class="highlighter-rouge">parallel-1</code>에서 시작되니 그 이후 동작도 다
<code class="highlighter-rouge">parallel-1</code>에서 실행되는 것입니다. <code class="highlighter-rouge">subscribeOn</code>으로 스케줄러를 지정하여 스위칭이 되면 이후 스트림은
계속 그 스케줄러에 의해 동작되기 때문입니다.</p>

<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/subscribeon.png" alt="subscribeOn 마블 다이어그램" /></p>

<p>이때 필요한 것이 <code class="highlighter-rouge">publishOn</code>연산자입니다. 이 연산자가 호출된 위치 이후에 실행되는 연산자들은
<code class="highlighter-rouge">publishOn</code>에서 지정된 스케줄러에서 실행되도록 할 수 있습니다. <code class="highlighter-rouge">subscribeOn</code>과의 차이점은 마블 다이어그램을
통해 확인하실 수 있습니다. 그렇다면 <code class="highlighter-rouge">publishOn</code>을 각각 <code class="highlighter-rouge">source</code> 바로 뒤에 호출되도록 붙여 보겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/publishon.png" alt="publishOn 마블 다이어그램" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">publish</span><span class="o">().</span><span class="na">autoConnect</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">()).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">().</span><span class="na">log</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">())</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                        <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                        <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                    <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
            <span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="cm">/* 생략.. */</span><span class="o">);</span>
</code></pre></div></div>

<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...생략...
[ INFO] (main) | onNext(kiwi)
[ INFO] (main) | onNext(orange)
[ INFO] (main) | onNext(lemon)
[ INFO] (main) | onNext(orange)
[ INFO] (main) | onNext(lemon)
[ INFO] (main) | onNext(kiwi)
[ INFO] (main) | onComplete()
[ INFO] (parallel-1) | onNext([kiwi, orange, lemon])
[ INFO] (parallel-1) | onComplete()
[ INFO] (parallel-2) | onNext({kiwi=2, orange=2, lemon=2})
FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
..중략..
[ INFO] (parallel-2) | onNext(banana)
[ INFO] (parallel-2) | onNext(lemon)
[ INFO] (parallel-2) | onNext(lemon)
[ INFO] (parallel-2) | onNext(kiwi)
[ INFO] (parallel-2) | onComplete()
[ INFO] (parallel-3) | onNext([banana, lemon, kiwi])
[ INFO] (parallel-3) | onComplete()
[ INFO] (parallel-4) | onNext({banana=1, lemon=2, kiwi=1})
FruitInfo{distinctFruits=[banana, lemon, kiwi], countFruits={banana=1, lemon=2, kiwi=1}}
...생략...
</code></pre></div></div>

<p>의도한 대로 각각 <code class="highlighter-rouge">parallel-1</code>과 <code class="highlighter-rouge">parallel-2</code>에서 실행되는 것을 확인할 수 있습니다. 그런데 처음에
<code class="highlighter-rouge">source</code>에서 시작할 때는 <code class="highlighter-rouge">main</code>스레드에서 시작하다가 <code class="highlighter-rouge">publishOn</code>으로 전체 스트림의 스케줄러가 바뀌면서
그다음 <code class="highlighter-rouge">source</code>는 <code class="highlighter-rouge">parallel-2</code>에서 실행되는 것을 확인할 수 있습니다. 만약 <code class="highlighter-rouge">source</code>가 하나의 지정한
스레드에서만 실행되도록 하고 싶다면 <code class="highlighter-rouge">source</code>에 <code class="highlighter-rouge">subscribeOn</code>을 추가할 수 있습니다. 이렇게 되면
<code class="highlighter-rouge">source</code>는 해당 스케줄러에 의해 동작하고 그 이후는 <code class="highlighter-rouge">publishOn</code>에 의해 바뀔 수 있습니다. 어떤 스케줄러를
지정할지는 필요에 따라 다를 듯 하지만, <a href="http://projectreactor.io/docs/core/snapshot/reference/#schedulers">Reactor 공식문서 스케줄러</a>를 읽어보고
저의 경우는 <code class="highlighter-rouge">Schedulers.single()</code>을 선택했습니다. 호출할 때마다 같은 스레드를 유지할 수
있기 때문에 매번 <code class="highlighter-rouge">source</code>를 구독할 때마다 같은 스레드에서 동작할 수 있기 때문입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basketFlux</span><span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">basket</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Flux</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Flux</span><span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="n">basket</span><span class="o">).</span><span class="na">log</span><span class="o">().</span><span class="na">publish</span><span class="o">().</span><span class="na">autoConnect</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">single</span><span class="o">());</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">distinctFruits</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">()).</span><span class="na">distinct</span><span class="o">().</span><span class="na">collectList</span><span class="o">().</span><span class="na">log</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">countFruitsMono</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">())</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">fruit</span> <span class="o">-&gt;</span> <span class="n">fruit</span><span class="o">)</span> <span class="c1">// 바구니로 부터 넘어온 과일 기준으로 group을 묶는다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">groupedFlux</span> <span class="o">-&gt;</span> <span class="n">groupedFlux</span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">count</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">fruitCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                        <span class="n">fruitCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">groupedFlux</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">count</span><span class="o">);</span>
                        <span class="k">return</span> <span class="n">fruitCount</span><span class="o">;</span>
                    <span class="o">})</span> <span class="c1">// 각 과일별로 개수를 Map으로 리턴</span>
            <span class="o">)</span> <span class="c1">// concatMap으로 순서보장</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">accumulatedMap</span><span class="o">,</span> <span class="n">currentMap</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">accumulatedMap</span><span class="o">);</span>
                <span class="n">putAll</span><span class="o">(</span><span class="n">currentMap</span><span class="o">);</span>
            <span class="o">}})</span> <span class="c1">// 그동안 누적된 accumulatedMap에 현재 넘어오는 currentMap을 합쳐서 새로운 Map을 만든다. // map끼리 putAll하여 하나의 Map으로 만든다.</span>
            <span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">Flux</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span><span class="n">distinctFruits</span><span class="o">,</span> <span class="n">countFruitsMono</span><span class="o">,</span> <span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span><span class="n">distinct</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
<span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span><span class="cm">/* 생략.. */</span><span class="o">);</span>
</code></pre></div></div>

<p>결과 (설명상 필요한 부분만)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] (single-1) | onNext(kiwi)
[ INFO] (single-1) | onNext(orange)
[ INFO] (single-1) | onNext(lemon)
[ INFO] (single-1) | onNext(orange)
[ INFO] (single-1) | onNext(lemon)
[ INFO] (single-1) | onNext(kiwi)
[ INFO] (single-1) | onComplete()
[ INFO] (parallel-1) | onNext([kiwi, orange, lemon])
[ INFO] (parallel-1) | onComplete()
[ INFO] (parallel-2) | onNext({kiwi=2, orange=2, lemon=2})
FruitInfo{distinctFruits=[kiwi, orange, lemon], countFruits={kiwi=2, orange=2, lemon=2}}
[ INFO] (single-1) | onNext(banana)
[ INFO] (single-1) | onNext(lemon)
[ INFO] (single-1) | onNext(lemon)
[ INFO] (single-1) | onNext(kiwi)
[ INFO] (single-1) | onComplete()
[ INFO] (parallel-3) | onNext([banana, lemon, kiwi])
[ INFO] (parallel-4) | onNext({banana=1, lemon=2, kiwi=1})
[ INFO] (parallel-3) | onComplete()
FruitInfo{distinctFruits=[banana, lemon, kiwi], countFruits={banana=1, lemon=2, kiwi=1}}
[ INFO] (single-1) | onSubscribe([Synchronous Fuseable] FluxIterable.IterableSubscription)
[ INFO] (single-1) | onNext(strawberry)
[ INFO] (single-1) | onNext(orange)
[ INFO] (single-1) | onNext(lemon)
[ INFO] (single-1) | onNext(grape)
[ INFO] (single-1) | onNext(strawberry)
[ INFO] (single-1) | onComplete()
[ INFO] (parallel-5) | onNext([strawberry, orange, lemon, grape])
[ INFO] (parallel-6) | onNext({strawberry=2, orange=1, lemon=1, grape=1})
[ INFO] (parallel-5) | onComplete()
</code></pre></div></div>

<p>결과는 필요한 부분만 뽑아 보았습니다. <code class="highlighter-rouge">source</code>는 <code class="highlighter-rouge">single-1</code>이라는 스레드에서 항상 동작하고, 그 이후에는
각각 <code class="highlighter-rouge">parallel-1</code>과<code class="highlighter-rouge">parallel-2</code>, <code class="highlighter-rouge">parallel-3</code>과<code class="highlighter-rouge">parallel-4</code>, <code class="highlighter-rouge">parallel-5</code>과<code class="highlighter-rouge">parallel-6</code>으로
동작하는 것을 확인할 수 있습니다.</p>

<h4 id="디버깅과-테스팅">디버깅과 테스팅</h4>

<h5 id="디버깅">디버깅</h5>
<p><code class="highlighter-rouge">Reactor</code>나 <code class="highlighter-rouge">RxJava</code>와 같이 스트림을 여러 연산자의 조합으로 체이닝 동작하는 방식의 라이브러리는
디버깅이나 테스트가 쉽지 않은 점이 있습니다. 예를 들어 에러가 났을 때 어떤 연산자에서 오류가 났는지 알기
어려워서 중간에 <code class="highlighter-rouge">doOnNext</code>와 같은 연산자로 로그를 찍어야 할 수도 있습니다. 물론 <code class="highlighter-rouge">Reactor</code>에는 앞서
소개한 <code class="highlighter-rouge">log()</code>라는 연산자도 있어서 편리하게 로그를 찍어볼 수 있습니다. 그러나 이 <code class="highlighter-rouge">log()</code>도 직전의
값만 출력해주기 때문에 사이사이에 <code class="highlighter-rouge">log()</code>를 넣어주는 것도 번거로워 보였습니다. 그래서 <code class="highlighter-rouge">Reactor</code>의
<a href="http://projectreactor.io/docs/core/snapshot/reference/#debug-activate">디버깅 관련된 문서</a>를
찾아보았습니다. Flux나 Mono를 구독하기 전 애플리케이션 시작 단계에서 <code class="highlighter-rouge">Hooks.onOperatorDebug();</code>를
호출하면 디버깅 모드를 활성화할 수 있으며, 이럴 경우 에러가 발생했을 때 출력되는 스택트레이스에 시작부터
에러가 났을 때까지 연산자의 목록을 모두 볼 수 있습니다. 공식문서에서는 다음과 같이 나온다고 소개되어 있는데,
해보니 실제로 에러가 났을 때 연산자들이 나오는 것을 확인할 수 있었습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error has been observed by the following operator(s):
        |_        Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
        |_        Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
        |_        Flux.filter ⇢ reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
        |_        Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)
        |_        Flux.elapsed ⇢ reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
        |_        Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)
</code></pre></div></div>

<h5 id="테스팅">테스팅</h5>
<p>테스트 코드 작성을 위해 <a href="http://projectreactor.io/docs/core/snapshot/reference/#testing">테스트 관련 문서</a>를
참고해 보았습니다. <code class="highlighter-rouge">io.projectreactor:reactor-test</code>를 의존성으로 추가하고 <code class="highlighter-rouge">StepVerifier</code>를
통해 테스트 코드를 작성할 수 있었습니다. <code class="highlighter-rouge">StepVerifier.create</code>로 테스트할 객체를 만들 때 인자로
테스트 대상이 되는 <code class="highlighter-rouge">Flux</code>나 <code class="highlighter-rouge">Mono</code>를 넘깁니다. 그리고 테스트에 필요한 메서드들을 연달아서 호출해서
기대한 값이 나왔는지 확인할 수 있습니다. 여기서는 <code class="highlighter-rouge">expectNext</code>와 <code class="highlighter-rouge">verifyComplete</code>를 이용해서
<code class="highlighter-rouge">next</code>로 넘어온 값이 기대한 값인지 그리고 <code class="highlighter-rouge">complete</code>이 호출되었는지 검증해보도록 하겠습니다. 여기서
<code class="highlighter-rouge">getFruitsFlux()</code>는 지금까지 만든 예제와 관련된 <code class="highlighter-rouge">Flux</code>를 리턴하는 메서드이며, JUnit4를 이용하여
테스트해보았습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testFruitBaskets</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">FruitInfo</span> <span class="n">expected1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"kiwi"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"kiwi"</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"orange"</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"lemon"</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
        <span class="o">}}</span>
    <span class="o">);</span>
    <span class="kd">final</span> <span class="n">FruitInfo</span> <span class="n">expected2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"banana"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"kiwi"</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"banana"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"lemon"</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"kiwi"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
        <span class="o">}}</span>
    <span class="o">);</span>
    <span class="kd">final</span> <span class="n">FruitInfo</span> <span class="n">expected3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitInfo</span><span class="o">(</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"strawberry"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">,</span> <span class="s">"grape"</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="o">{</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"strawberry"</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"orange"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"lemon"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"grape"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
        <span class="o">}}</span>
    <span class="o">);</span>
    <span class="n">StepVerifier</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">getFruitsFlux</span><span class="o">())</span>
        <span class="o">.</span><span class="na">expectNext</span><span class="o">(</span><span class="n">expected1</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expectNext</span><span class="o">(</span><span class="n">expected2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expectNext</span><span class="o">(</span><span class="n">expected3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">verifyComplete</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>테스트는 잘 통과되는 것을 확인할 수 있고, 값을 값을 하나 바꿔서 실패하게 만들면 어떤 값이 스트림에서
넘어왔는데 기대하는 값은 무엇인지도 잘 출력됩니다. 그리고 <code class="highlighter-rouge">verifyComplete</code>이 리턴하는 타입은
<a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html">Duration</a>이란
타입인데, 여기에는 테스트하는 동안 걸린 시간 정보가 들어가게 됩니다.</p>

<h2 id="마치며">마치며</h2>
<p>지금까지 간단한 예제를 이용해 Reactor의 연산자들을 어떻게 조합해서 데이터를 변환하는지, <code class="highlighter-rouge">Cold</code>에서
<code class="highlighter-rouge">Hot</code>으로 변환하는 과정을 이해하고 하나의 스트림에서 여러 스트림으로 나갈 때 어떻게 하는지, 스케줄러를
지정해 어떻게 실행 컨텍스트를 전환시켰는지 살펴보았습니다. 그밖에 <code class="highlighter-rouge">log()</code>나 디버깅 모드를 활용해서 에러난
위치나 스트림의 흐름을 쉽게 볼 수 있다는 것도 유용해 보였습니다. <br />
스프링 프레임워크 5부터는 리액티브 프로그래밍을 할 수 있게 <code class="highlighter-rouge">Reactor</code>와 <code class="highlighter-rouge">RxJava</code>를 사용하도록 지원해주고
있지만, 현재는 실무에서 보편적으로 사용되는 것 같아 보이진 않습니다. <code class="highlighter-rouge">RxJava</code>에 익숙하다면 <code class="highlighter-rouge">Reactor</code>도
공식문서를 보고 적응하기 어렵지 않아 보였습니다.  <br />
사용하면서 어려운 점은 연산자만으로 해결이 가능한 부분이 있음에도 아직 익숙하지 않고 높은 학습곡선과 수많은
연산자들을 다 모르기에, 중간에 <code class="highlighter-rouge">Flux</code>나 <code class="highlighter-rouge">Mono</code>에서 값을 꺼내서 동기방식과 명령형 프로그래밍으로 조작한 후
다시 넣어야 하나 유혹을 받는 경우가 온다는 것입니다. 이렇게 하면 함수형 프로그래밍과 명령형 프로그래밍이 섞여
있어 코드도 복잡해지고 중간에 <code class="highlighter-rouge">block</code> 같은 연산자를 써서 논 블록킹 라이브러리의 장점을 살릴 수 없는 상황이
오게 된다는 것입니다. 따라서 <code class="highlighter-rouge">Reactor</code>를 사용하여 리액티브 프로그래밍을 해야 하는 상황을 고려한다면,
<code class="highlighter-rouge">1) 필요한 이유</code>, <code class="highlighter-rouge">2) 추후 코드 변경 시 유지보수성</code>, <code class="highlighter-rouge">3)함께 협업하는 사람들의 숙련도나 관심</code>
등을 고려하여 선택해야 한다고 생각합니다. 필자의 경험으로는 여러 스레드를 전환해야 해서 순서가 복잡해져서
그 사이에 순서를 잘 관리하거나, 복잡하게 데이터를 변환해야 하는 경우, 그리고 여러 스트림을 블록킹으로 처리하기보다
논 블록킹으로 처리하기 좋은 경우에 <code class="highlighter-rouge">Reactor</code>나 <code class="highlighter-rouge">RxJava</code>같은 라이브러리가 유용해 보였습니다.  <br />
이번에 <code class="highlighter-rouge">Reactor</code>를 사용해보면서 정리했으면 좋겠다는 패턴이 보여서 간단한 예제로 정리를 했습니다. 본문에서
<code class="highlighter-rouge">Reactor</code>의 모든 것을 다룰 순 없었어도, 필요한 부분이 참고가 돼서 Reactor 같은 라이브러리로
리액티브 프로그래밍을 하는데 도움이 되었으면 좋겠습니다.</p>

  </div><a class="u-url" href="/2018/05/29/reactor-programming/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
