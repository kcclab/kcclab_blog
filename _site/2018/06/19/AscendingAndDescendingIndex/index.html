<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>MySQL Ascending index vs Descending index | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="MySQL Ascending index vs Descending index" />
<meta name="author" content="matt.lee" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="용어 정리 이 설명에서는 인덱스의 정렬 순서와 데이터 읽기 순서 등 방향에 대한 단어들이 혼재하면서, 여러 가지 혼란을 초래하기 쉬운 설명들이 있을 것으로 보인다. 그래서 우선 표준 용어는 아니지만, 나름대로 몇 개 단어들에 대해서 개념을 정립하고 그 단어를 번역 없이 영어로 그대로 표기하도록 하겠다." />
<meta property="og:description" content="용어 정리 이 설명에서는 인덱스의 정렬 순서와 데이터 읽기 순서 등 방향에 대한 단어들이 혼재하면서, 여러 가지 혼란을 초래하기 쉬운 설명들이 있을 것으로 보인다. 그래서 우선 표준 용어는 아니지만, 나름대로 몇 개 단어들에 대해서 개념을 정립하고 그 단어를 번역 없이 영어로 그대로 표기하도록 하겠다." />
<link rel="canonical" href="http://localhost:4000/2018/06/19/AscendingAndDescendingIndex/" />
<meta property="og:url" content="http://localhost:4000/2018/06/19/AscendingAndDescendingIndex/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:image" content="http://localhost:4000/files/covers/solid-state-logic.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-19T15:00:00+09:00" />
<script type="application/ld+json">
{"datePublished":"2018-06-19T15:00:00+09:00","dateModified":"2018-06-19T15:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/06/19/AscendingAndDescendingIndex/"},"url":"http://localhost:4000/2018/06/19/AscendingAndDescendingIndex/","image":"http://localhost:4000/files/covers/solid-state-logic.jpg","author":{"@type":"Person","name":"matt.lee"},"description":"용어 정리 이 설명에서는 인덱스의 정렬 순서와 데이터 읽기 순서 등 방향에 대한 단어들이 혼재하면서, 여러 가지 혼란을 초래하기 쉬운 설명들이 있을 것으로 보인다. 그래서 우선 표준 용어는 아니지만, 나름대로 몇 개 단어들에 대해서 개념을 정립하고 그 단어를 번역 없이 영어로 그대로 표기하도록 하겠다.","@type":"BlogPosting","headline":"MySQL Ascending index vs Descending index","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Your awesome title</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        <!--
            my_page.autogen is populated by the pagination logic for all pages
                            that are automatically created by the gem. Check for non-existence to exclude pagination pages from site.pages iterators
          -->
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/index.html">Your awesome title</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MySQL Ascending index vs Descending index</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-06-19T15:00:00+09:00" itemprop="datePublished">Jun 19, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">matt.lee</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="용어-정리">용어 정리</h1>
<p>이 설명에서는 인덱스의 정렬 순서와 데이터 읽기 순서 등 방향에 대한 단어들이 혼재하면서, 여러 가지 혼란을 초래하기 쉬운 설명들이 있을 것으로 보인다. 그래서 우선 표준 용어는 아니지만, 나름대로 몇 개 단어들에 대해서 개념을 정립하고 그 단어를 번역 없이 영어로 그대로 표기하도록 하겠다.</p>

<p><img src="/files/Terms.png" alt="용어 설명" /></p>

<ul>
  <li><code class="highlighter-rouge">Ascending index</code> : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스</li>
  <li><code class="highlighter-rouge">Descending index</code> : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스</li>
  <li><code class="highlighter-rouge">Forward index scan</code> (Forward scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔</li>
  <li><code class="highlighter-rouge">Backward index scan</code> (Backward scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔</li>
</ul>

<h1 id="descending-index-지원">Descending index 지원</h1>

<p>MySQL 4.x 버전부터 <a href="https://bugs.mysql.com/bug.php?id=13375">Feature Request</a>로 등록되어 있던 “<code class="highlighter-rouge">Descending index</code>” 기능이 드디어 MySQL 8.0에 도입되었다.
MySQL 8.0부터는 이제 아래와 같이 역순으로 정렬되는 인덱스(<code class="highlighter-rouge">Descending index</code>)를 생성할 수 있게 되었으며, 필요에 따라서 적절히 정순(ORDER BY ASC)과 역순(ORDER BY DESC)을 혼합해서 정렬하는 작업을 인덱스를 이용할 수 있게 된 것이다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tb_wow</span> <span class="p">(</span>
  <span class="n">uid</span> <span class="n">BIGINT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">age</span> <span class="n">SMALLINT</span><span class="p">,</span>
  <span class="n">score</span> <span class="n">SMALLINT</span><span class="p">,</span>
  <span class="k">INDEX</span> <span class="n">ix_score_age</span> <span class="p">(</span><span class="n">score</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">age</span> <span class="k">ASC</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tb_wow</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">score</span> <span class="k">ASC</span><span class="p">,</span>  <span class="n">age</span> <span class="k">DESC</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tb_wow</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">score</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">age</span> <span class="k">ASC</span> <span class="p">;</span>
</code></pre></div></div>

<p>아마도 MySQL 8.0 이전에도 <code class="highlighter-rouge">Descending index</code>가 지원되었다고 생각했을 수도 있는데, MySQL 8.0 이전에는 문법만 지원되고 실제 <code class="highlighter-rouge">Descending index</code>가 지원되는 것은 아니었다. 또한 <code class="highlighter-rouge">Ascending index</code>를 <code class="highlighter-rouge">Forward scan</code>하는 것과 <code class="highlighter-rouge">Backward scan</code>하는 것만으로 <code class="highlighter-rouge">Descending index</code>의 요건을 충분히 만족한다고 생각할 수도 있지만, 실제 그렇지 못한 경우도 많다.</p>

<p>MySQL 8.0에 도입된 <code class="highlighter-rouge">Descending index</code>가 필요한 가장 큰 이유는 이미 살펴본 예제와 같이 정순(ORDER BY ASC)과 역순(ORDER BY DESC) 정렬을 섞어서 여러 컬럼으로 정렬하는 경우일 것이다. 그런데 <code class="highlighter-rouge">Descending index</code>가 필요한 이유가 오직 이것뿐일까?</p>

<h1 id="descending-index를-사용해야-하는-또-다른-이유">Descending index를 사용해야 하는 또 다른 이유</h1>
<p>MySQL 8.0 이전 버전을 사용하면서 역순 정렬이 필요한 경우에는, 크게 성능에 대한 고려 없이 지금까지 <code class="highlighter-rouge">Ascending index</code>를 생성하고 “ORDER BY index_column DESC” 쿼리로 인덱스를 <code class="highlighter-rouge">Backward scan</code>으로 읽는 실행 계획을 사용해왔다. 이제 <code class="highlighter-rouge">Ascending index</code>를 <code class="highlighter-rouge">Forward scan</code>하는 경우와 Backward scan하는 경우의 성능 비교를 간단히 예제로 한번 살펴보자.</p>

<p>우선 아래와 같이 information_schema.COLUMNS 테이블의 레코드를 복사해서 대략 1천2백여만 건의 레코드를 가지는 테이블을 만들어 보자.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
  <span class="n">tid</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="k">TABLE_NAME</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
  <span class="k">COLUMN_NAME</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
  <span class="n">ORDINAL_POSITION</span> <span class="n">INT</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">SELECT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">TABLE_NAME</span><span class="p">,</span> <span class="k">COLUMN_NAME</span><span class="p">,</span> <span class="n">ORDINAL_POSITION</span> <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">SELECT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">TABLE_NAME</span><span class="p">,</span> <span class="k">COLUMN_NAME</span><span class="p">,</span> <span class="n">ORDINAL_POSITION</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">-- // 12번 실행</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+</span>
<span class="o">|</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+</span>
<span class="o">|</span> <span class="mi">12619776</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+</span>
</code></pre></div></div>

<p>이제 이 테이블을 풀 스캔 하면서 정렬만 수행하는 쿼리를 아래와 같이 한번 실행해보자. 아래 두 쿼리는 테이블의 프라이머리 키를 <code class="highlighter-rouge">Forward scan</code> 또는 <code class="highlighter-rouge">Backward scan</code>으로 읽어서 마지막 레코드 1건만 반환하게 된다. 첫번째 쿼리는 tid 컬럼의 값이 가장 큰 레코드 1건을 그리고 두번째 쿼리는 tid 컬럼의 값이 가장 작은 레코드 1건을 반환하게 된다. 하지만 LIMIT .. OFFSET .. 부분의 쿼리로 인해서, 실제 MySQL 서버는 테이블의 모든 레코드를 스캔해야만 한다. (이 쿼리는 모든 레코드를 스캔하는 작업은 하지만, 화면에는 레코드 1건만 출력하려고 LIMIT .. OFFSET .. 옵션을 추가한 것임)</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tid</span> <span class="k">ASC</span>  <span class="k">LIMIT</span> <span class="mi">12619775</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tid</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">12619775</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>위 두 쿼리의 실행 결과는 어떤 차이를 보여줄지 먼저 한번 예측해보자. 지금까지는 많은 사용자들이 두 쿼리가 동일한 실행 시간을 보여줄 것이라 믿어 의심치 않았을 것이다. 당연히 그렇게 작동해야 하니까 고려 대상조차 아니었다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tid</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">12619775</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">14</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">15</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">15</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">14</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">15</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tid</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">12619775</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">35</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">35</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">35</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">36</span> <span class="n">sec</span><span class="p">)</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">35</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>테스트 환경 (CPU Bound 테스트)</p>
  <ul>
    <li>CPU : Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz (x 24)</li>
    <li>MEMORY : 64GB</li>
    <li>DISK : NVME SSD</li>
    <li>TABLE SIZE (Disk) : 883MB</li>
    <li>MySQL configuration
      <ul>
        <li>innodb_buffer_pool_instances=2</li>
        <li>innodb_buffer_pool_size=30G</li>
        <li>innodb_adaptive_hash_index=OFF</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>1천2백여만건을 스캔하는데, “1.2초 정도의 차이쯤이야!!”라고 생각할 수도 있다. 하지만 비율로 따져보면, 역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 더 시간이 걸리는 것을 확인할 수 있다. 하나의 인덱스를 정순으로 읽느냐 또는 역순으로 읽느냐에 따라서 이런 차이가 발생한다는 것은 쉽게 이해하기 어렵다.</p>

<h1 id="backward-index-scan이-느린-이유">Backward index scan이 느린 이유</h1>
<p>MySQL 서버의 InnoDB 스토리지 엔진에서 (많은 사용자들이 이미 잘 알고 있듯이) Forward &amp; <code class="highlighter-rouge">Backward index scan</code> 페이지(블록) 간의 양방향 연결 고리(Double linked list)를 통해서 전진(Forward)하느냐 후진(Backward)하느냐의 차이만 있다. 이것만 보면 Forward와 <code class="highlighter-rouge">Backward index scan</code>의 성능 차이는 이해되지 않는다.</p>

<p>실제 InnoDB에서 <code class="highlighter-rouge">Backward index scan</code>이 <code class="highlighter-rouge">Forward index scan</code>에 비해서 느릴 수밖에 없는 2가지 이유를 가지고 있다.</p>
<ul>
  <li>페이지 잠금이 <code class="highlighter-rouge">Forward index scan</code>에 적합한 구조</li>
  <li>페이지 내에서 인덱스 레코드는 단방향으로만 연결된 구조 (Forwarded single linked link)</li>
</ul>

<h3 id="1-페이지-잠금이-forward-index-scan에-적합한-구조">1. 페이지 잠금이 <code class="highlighter-rouge">Forward index scan</code>에 적합한 구조</h3>
<p>InnoDB의 페이지 잠금 방식은 <code class="highlighter-rouge">Forward index scan</code>을 중심으로 구현되어 있는데, <code class="highlighter-rouge">Forward index scan</code>으로 인덱스 리프 페이지를 읽을 때는, 아래 <a href="https://github.com/mysql/mysql-server/blob/mysql-5.7.22/storage/innobase/btr/btr0pcur.cc#L403-L462">코드</a> 샘플과 같이 페이지의 잠금을 획득할 때에는 Forward scan 순서대로 잠금을 걸고 다시 잠금을 해제하게 된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="n">btr_pcur_move_to_next_page</span><span class="p">(</span>
<span class="cm">/*=======================*/</span>
    <span class="n">btr_pcur_t</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="cm">/*!&lt; in: persistent cursor; must be on the
                last record of the current page */</span>
    <span class="n">mtr_t</span><span class="o">*</span>      <span class="n">mtr</span><span class="p">)</span>    <span class="cm">/*!&lt; in: mtr */</span>
<span class="p">{</span>
    <span class="c1">// ... skip ...</span>

    <span class="n">page</span> <span class="o">=</span> <span class="n">btr_pcur_get_page</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
    <span class="n">next_page_no</span> <span class="o">=</span> <span class="n">btr_page_get_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="c1">// ... skip ...</span>
    
    <span class="n">buf_block_t</span><span class="o">*</span>    <span class="n">block</span> <span class="o">=</span> <span class="n">btr_pcur_get_block</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>

    <span class="c1">// 다음 페이지(next page)를 찾아서, 잠금 획득</span>
    <span class="n">next_block</span> <span class="o">=</span> <span class="n">btr_block_get</span><span class="p">(</span>
        <span class="n">page_id_t</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">space</span><span class="p">(),</span> <span class="n">next_page_no</span><span class="p">),</span>
        <span class="n">block</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
        <span class="n">btr_pcur_get_btr_cur</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="n">next_page</span> <span class="o">=</span> <span class="n">buf_block_get_frame</span><span class="p">(</span><span class="n">next_block</span><span class="p">);</span>

    <span class="c1">// ... skip ...</span>
    
    <span class="c1">// 다음 페이지(next page) 잠금 획득후, 현재 페이지(이전 페이지)의 잠금을 해제</span>
    <span class="n">btr_leaf_page_release</span><span class="p">(</span><span class="n">btr_pcur_get_block</span><span class="p">(</span><span class="n">cursor</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="c1">// ... skip ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">Backward index scan</code>시에 페이지 잠금을 획득하는 <a href="https://github.com/mysql/mysql-server/blob/mysql-5.7.22/storage/innobase/btr/btr0pcur.cc#L473-L546">코드</a> 샘플을 한번 살펴보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">btr_pcur_move_backward_from_page</span><span class="p">(</span>
<span class="cm">/*=============================*/</span>
        <span class="n">btr_pcur_t</span><span class="o">*</span>     <span class="n">cursor</span><span class="p">,</span> <span class="cm">/*!&lt; in: persistent cursor, must be on the first
                                record of the current page */</span>
        <span class="n">mtr_t</span><span class="o">*</span>          <span class="n">mtr</span><span class="p">)</span>    <span class="cm">/*!&lt; in: mtr */</span>
<span class="p">{</span>
    <span class="c1">// ... skip ...</span>
    <span class="c1">// 커서의 현재 상태 백업</span>
    <span class="n">btr_pcur_store_position</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="n">mtr_commit</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>  <span class="c1">// Mini-transaction 커밋 (페이지 잠금 해제)</span>

    <span class="n">mtr_start</span><span class="p">(</span><span class="n">mtr</span><span class="p">);</span>   <span class="c1">// Mini-transaction 시작</span>

    <span class="c1">// BTR_SEARCH_PREV 모드로 커서 복구</span>
    <span class="n">btr_pcur_restore_position</span><span class="p">(</span><span class="n">latch_mode2</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="n">page</span> <span class="o">=</span> <span class="n">btr_pcur_get_page</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>

    <span class="n">prev_page_no</span> <span class="o">=</span> <span class="n">btr_page_get_prev</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

    <span class="cm">/* For intrinsic table we don't do optimistic restore and so there is
       no left block that is pinned that needs to be released. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dict_table_is_intrinsic</span><span class="p">(</span>
         <span class="n">btr_cur_get_index</span><span class="p">(</span><span class="n">btr_pcur_get_btr_cur</span><span class="p">(</span><span class="n">cursor</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev_page_no</span> <span class="o">==</span> <span class="n">FIL_NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btr_pcur_is_before_first_on_page</span><span class="p">(</span><span class="n">cursor</span><span class="p">))</span> <span class="p">{</span>

            <span class="n">prev_block</span> <span class="o">=</span> <span class="n">btr_pcur_get_btr_cur</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left_block</span><span class="p">;</span>
            <span class="c1">// 불필요시 현재 페이지 잠금 해제</span>
            <span class="n">btr_leaf_page_release</span><span class="p">(</span><span class="n">btr_pcur_get_block</span><span class="p">(</span><span class="n">cursor</span><span class="p">),</span>
                                        <span class="n">latch_mode</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>

            <span class="n">page_cur_set_after_last</span><span class="p">(</span><span class="n">prev_block</span><span class="p">,</span>
                                        <span class="n">btr_pcur_get_page_cur</span><span class="p">(</span><span class="n">cursor</span><span class="p">));</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* The repositioned cursor did not end on an infimum
               record on a page. Cursor repositioning acquired a latch
               also on the previous page, but we do not need the latch:
               release it. */</span>

            <span class="n">prev_block</span> <span class="o">=</span> <span class="n">btr_pcur_get_btr_cur</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">left_block</span><span class="p">;</span>
            <span class="c1">// 불필요시 이전 페이지(Backward page) 잠금 해제</span>
            <span class="n">btr_leaf_page_release</span><span class="p">(</span><span class="n">prev_block</span><span class="p">,</span> <span class="n">latch_mode</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">latch_mode</span> <span class="o">=</span> <span class="n">latch_mode</span><span class="p">;</span>
    <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">old_stored</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>대략 코드를 읽어보면, (100% 이해는 어렵더라도) 대략 <code class="highlighter-rouge">Backward index scan</code>으로 이전 페이지로 넘어가는 과정은 아래와 같은 처리가 발생하는 것을 알 수 있다.</p>
<ol>
  <li>커서의 상태를 저장하고 내부 미니 트랜잭션을 커밋해서 미니 트랜잭션 버퍼를 글로벌 리두 로그 버퍼로 복사</li>
  <li>미니 트랜잭션을 재시작</li>
  <li>커서의 상태를 다시 복구 (이 과정에서 현재 블록이 이동되는 것을 막기 위해서 pinning을 하고 필요에 따라서 현재 블록과 이전 블록(Backward block)의 잠금을 획득)</li>
</ol>

<p>InnoDB의 B-Tree 리프 페이지는 Double linked list로 연결되어 있기 때문에, 사실 어느 방향이든지 이동 자체는 차이가 없다. 하지만 InnoDB 스토리지 엔진에서는 페이지 잠금 과정에서 데드락을 방지하기 위해서 B-Tree의 왼쪽에서 오른쪽 순서(Forward)로만 잠금을 획득하도록 하고 있다. 그래서 <code class="highlighter-rouge">Forward index scan</code>에서는 다음 페이지 잠금 획득이 매우 간단하지만, <code class="highlighter-rouge">Backward index scan</code>에서 이전 페이지 잠금을 획득하는 과정은 상당히 복잡한 과정을 거치게 된다.</p>

<p>이런 차이로 인서 많은 페이지를 스캔해야 하는 Index scan에서는 잠금 획득으로 인한 쿼리 처리 지연이 발생하게 된다.</p>

<h3 id="2-페이지-내에서-인덱스-레코드는-단방향으로만-연결된-구조">2. 페이지 내에서 인덱스 레코드는 단방향으로만 연결된 구조</h3>
<p>InnoDB 스토리지 엔진이 특정 레코드를 검색할 때, B-Tree를 이용해서 검색 대상 레코드(인덱스 엔트리)가 저장된 페이지(Block)까지는 검색할 수 있다. 하지만 그 페이지 내에도 수많은 레코드가 저장되어 있는데, 일반적으로 20바이트 키를 저장하는 인덱스 페이지(16K)라면, 대략 600여개 이상의 레코드가 저장될 수 있다. InnoDB 스토리지 엔진이 600여개 레코드를 하나씩 다 순차적으로 비교한다면 레코드 검색이 상당히 느릴 것이다. 그래서 InnoDB 스토리지 엔진은 하나의 페이지내에서 순차적으로 정렬된 레코드 4~8개 정도씩을 묶어서 대표 키(가장 큰 인덱스 엔트리 키 값)를 선정한다. 그리고 이 대표 키들만 모아서 별도의 리스트를 관리하는데, 이를 페이지 디렉토리(Page directory)라고 한다. 아래 그림은 “Jeremy Cole”이 그린 “<a href="https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/">InnoDB 자료 구조</a>“중에서 “InnoDB page directory” 그림을 캡처한 것이다. 이미 충분히 이해하기 쉽도록 그려져 있어 그대로 차용하고자 한다.</p>

<p><img src="/files/InnodbPageDirectory.png" alt="InnoDB Page Directory 구조" /></p>

<p>InnoDB 스토리지 엔진은 하나의 페이지에서 특정 키 값을 검색할 때 Page directory를 이용해서 바이너리 서치(Binary search) 방식으로 검색 대상 키를 포함하는 대표 키를 검색한다. 그리고 대표 키를 찾으면 그때부터는 인덱스 키 값 순서대로 연결된 Linked list를 이용해서 대상 레코드를 검색하게 된다.</p>

<p>그런데 Double linked list로 연결된 B-Tree의 리프 페이지 구조와는 달리, 페이지 내부의 레코드(인덱스 엔트리)들은 Single linked list 구조로 구성되어 있다. Single linked list는 <code class="highlighter-rouge">Ascending index</code>에서는 키 값이 오름차순으로 정렬되어서 Linked list로 구성되는 것이다. 만약 <code class="highlighter-rouge">Descending index</code>라면 키 값이 내림차순으로 정렬되어서 Linked list 구성될 것이다. 그래서 <code class="highlighter-rouge">Ascending index</code>에서 <code class="highlighter-rouge">Forward index scan</code>은 Linked list를 그대로 따라가기만 하면 되지만, <code class="highlighter-rouge">Backward index scan</code>은 그렇게 간단하지 않다.</p>

<p>아래 <a href="https://github.com/mysql/mysql-server/blob/mysql-5.7.22//storage/innobase/include/page0page.ic#L836-L871">코드</a> 샘플은 <code class="highlighter-rouge">Forward index scan</code>을 할 때 하나의 페이지에서 Page directory를 이용해서 다음 레코드를 찾아오는 방법을 보여주고 있다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNIV_INLINE</span>
<span class="k">const</span> <span class="n">rec_t</span><span class="o">*</span>
<span class="nf">page_rec_get_next_low</span><span class="p">(</span>
<span class="cm">/*==================*/</span>
    <span class="k">const</span> <span class="n">rec_t</span><span class="o">*</span>    <span class="n">rec</span><span class="p">,</span>    <span class="cm">/*!&lt; in: pointer to record */</span>
    <span class="n">ulint</span>        <span class="n">comp</span><span class="p">)</span>    <span class="cm">/*!&lt; in: nonzero=compact page layout */</span>
<span class="p">{</span>
    <span class="c1">// ... skip ...</span>
    
    <span class="n">page</span> <span class="o">=</span> <span class="n">page_align</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
    <span class="n">offs</span> <span class="o">=</span> <span class="n">rec_get_next_offs</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>

    <span class="c1">// ... skip ...</span>

    <span class="k">return</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">offs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">Forward index scan</code>은 단순히 Linked list만 따라가면 되기 때문에 코드 역시 매우 간단하다. 이제 <code class="highlighter-rouge">Backward index scan</code>의 <a href="https://github.com/mysql/mysql-server/blob/mysql-5.7.22//storage/innobase/include/page0page.ic#L950-L995">코드</a> 샘플을 한번 비교해보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNIV_INLINE</span>
<span class="k">const</span> <span class="n">rec_t</span><span class="o">*</span>
<span class="n">page_rec_get_prev_const</span><span class="p">(</span>
<span class="cm">/*====================*/</span>
    <span class="k">const</span> <span class="n">rec_t</span><span class="o">*</span>    <span class="n">rec</span><span class="p">)</span>    <span class="cm">/*!&lt; in: pointer to record, must not be page
                infimum */</span>
<span class="p">{</span>
    <span class="c1">// ... skip ...</span>
    
    <span class="n">page</span> <span class="o">=</span> <span class="n">page_align</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
    <span class="c1">// Page directory를 검색해서, 레코드를 저장하고 있는 슬롯(Directory)을 검색</span>
    <span class="n">slot_no</span> <span class="o">=</span> <span class="n">page_dir_find_owner_slot</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
    <span class="c1">// 현재 레코드가 저장된 슬롯의 이전 슬롯(slot_no-1)을 가져와서</span>
    <span class="n">slot</span> <span class="o">=</span> <span class="n">page_dir_get_nth_slot</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">slot_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 해당 슬롯의 대표 레코드를 가져온다</span>
    <span class="n">rec2</span> <span class="o">=</span> <span class="n">page_dir_slot_get_rec</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">page_is_comp</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// ... skip ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">rec</span> <span class="o">!=</span> <span class="n">rec2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prev_rec</span> <span class="o">=</span> <span class="n">rec2</span><span class="p">;</span>
            <span class="c1">// 다음 레코드가 자기 자신일 때까지 loop를 실행</span>
            <span class="c1">// 자기 자신 레코드를 찾으면, 그 이전 레코드가 이전 레코드이므로</span>
            <span class="n">rec2</span> <span class="o">=</span> <span class="n">page_rec_get_next_low</span><span class="p">(</span><span class="n">rec2</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ... skip ...</span>

    <span class="c1">// 검색된 이전 레코드 리턴</span>
    <span class="k">return</span><span class="p">(</span><span class="n">prev_rec</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>사실 코드 자체는 많이 복잡하지 않지만, Page directory별로 4~8개 정도의 레코드(인덱스 키 엔트리)가 저장되므로 <code class="highlighter-rouge">while loop</code>을 평균적으로 2~4번 정도씩 실행해야 이전 레코드(<code class="highlighter-rouge">Backwrad index scan</code>)를 찾을 수 있는 것이다.</p>

<h1 id="backward-index-scan의-서비스-영향도">Backward index scan의 서비스 영향도</h1>
<p>이로써 <code class="highlighter-rouge">Backward index scan</code>이 <code class="highlighter-rouge">Forward index scan</code>보다 느린 이유를 알게 되었다. 그렇다면 실제 <code class="highlighter-rouge">Backward index scan</code>을 사용하면 서비스가 엄청나게 느려지는 것일까? Forward index scan과 <code class="highlighter-rouge">Backward index scan</code>의 실제 서비스 영향도는 일반적으로 그렇게 크지 않았다. 아주 랜덤한 키 값으로 검색해서 Index range scan을 실행하는 경우 대략 아래 그래프와 같이 10% 정도의 쿼리 스루풋 차이를 보였으며, CPU 사용량의 차이는 미미했다 (Test thread를 16개 정도로 안정적인 쿼리 처리가 가능한 상황에서의 테스트 결과).</p>

<p><img src="/files/Random_CPU.png" alt="CPU usage on Random query test" />
<img src="/files/Random_QueryPerSecond.png" alt="Query throughput on Random query test" /></p>

<blockquote>
  <p><code class="highlighter-rouge">Forward index scan</code></p>
  <ul>
    <li>set @random_tid=floor(rand()*12994454);</li>
    <li>select tid from t1 where tid&gt;=@random_tid order by tid ASC limit 50;</li>
  </ul>

  <p><code class="highlighter-rouge">Backward index scan</code></p>
  <ul>
    <li>set @random_tid=floor(rand()*12994454);</li>
    <li>select tid from t1 where tid&lt;=@random_tid order by tid DESC limit 50;</li>
  </ul>
</blockquote>

<p>하지만 정렬된 Index의 특정 부분(인덱스의 앞부분 또는 끝부분)을 집중적으로 읽는 경우, 44% 정도의 스루풋 차이를 보이며 CPU 사용량도 큰 차이를 보였다.</p>

<p><img src="/files/Hotspot_CPU.png" alt="CPU usage on Hotspot query test" />
<img src="/files/Hotspot_QueryPerSecond.png" alt="Query throughput on Hotspot query test" /></p>

<blockquote>
  <p><code class="highlighter-rouge">Forward index scan</code></p>
  <ul>
    <li>select tid from t1 order by tid ASC limit 1000;</li>
  </ul>

  <p><code class="highlighter-rouge">Backward index scan</code></p>
  <ul>
    <li>select tid from t1 order by tid DESC limit 1000;</li>
  </ul>
</blockquote>

<p>첫번째 테스트에서는 매번 쿼리가 실행될 때마다 인덱스 스캔 위치를 랜덤하게 선택하도록 해서, 실제 각 쓰레드간의 페이지 잠금 경합이 그다지 심하지 않았던 것이다. 그리고 인덱스를 <code class="highlighter-rouge">Backward scan</code>하는 데 추가로 더 걸린 시간은 쿼리의 처리 시간에 그다지 크게 영향을 미치지 않았던 것이다. 그런데 이번 테스트 케이스(두번째 테스트 케이스)에서는 유입되는 모든 쿼리가 동일 페이지에 집중되는 상황인데, 이때에는 쿼리를 실행중인 쓰레드들끼리 경합을 하면서 아주 짧은 페이지 잠금 시간이 더 길어지는 효과를 내게 된 것이다. 그래서 쿼리의 <code class="highlighter-rouge">Ascending index scan</code>보다 <code class="highlighter-rouge">Descending index scan</code>이 훨씬 더 많은 쿼리 시간이 걸리게 된 것이다.</p>

<p>두번째 테스트 케이스에서는 1000건의 레코드를 조회(LIMIT 1000)하도록 했는데, 이 건수가 하나의 페이지에 저장된 레코드 건수보다 크면 <code class="highlighter-rouge">Ascending</code>과 <code class="highlighter-rouge">Descending index scan</code>의 성능 차이가 커졌으며, 조회 건수가 페이지에 저장된 레코드 건수보다 적으면 <code class="highlighter-rouge">Ascending</code>과 <code class="highlighter-rouge">Descending index scan</code>의 성능 차이는 줄어들었다. 즉 성능 차이에 영향을 미치는 2가지 구조적 이유 중에서, <code class="highlighter-rouge">페이지 잠금이 Forward index scan에 적합한 구조</code>가 더 크게 영향을 미치는 것으로 보인다.</p>

<p>사용자에게 일반적으로 노출되는 잠금(Table &amp; Row lock, …) 이외에도 InnoDB 스토리지 엔진에서는 내부적으로 페이지의 레코드를 접근할 때마다, 페이지에 대해서 잠금을 걸어야 한다. 이때 InnoDB 스토리지 엔진은 RW-lock(Semaphore)이 아닌 Mutex를 사용하기 때문에 읽기 쿼리와 쓰기 쿼리뿐만 아니라 읽기 쿼리들끼리도 페이지 잠금을 점유하기 위해서 경쟁해야 하기 때문에, 동시 쓰레드가 많아지면 많아질수록 성능 영향도는 더 커지게 되는 결과를 만들게 될 것으로 보인다.</p>

<blockquote>
  <p>참고로, 테이블의 데이터 파일을 구성하는 B-Tree의 각 페이지에 저장된 레코드 건수가 성능을 영향을 미치게 되는데, 이 테스트를 위한 테이블의 각 페이지에 저장된 레코드 건수는 아래와 같았다.</p>
  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-------+-------+-------+-------+-------+---------+--------------+
| page  | index | level | data  | free  | records | min_key      |
+-------+-------+-------+-------+-------+---------+--------------+
|     4 |    52 |     0 |  7443 |  8737 |     146 | tid=1        |
|     5 |    52 |     0 | 15035 |  1079 |     282 | tid=147      |
|     6 |    52 |     0 | 15084 |  1036 |     271 | tid=429      |
...
| 55354 |    52 |     0 | 15083 |  1057 |     229 | tid=12993805 |
| 55355 |    52 |     0 | 15095 |  1049 |     222 | tid=12994034 |
| 55356 |    52 |     0 | 13049 |  3107 |     199 | tid=12994256 |
+-------+-------+-------+-------+-------+---------+--------------+
</code></pre></div>  </div>
</blockquote>

<h1 id="ascending-vs-descending-index의-선택-기준">Ascending vs Descending index의 선택 기준</h1>
<p>일반적으로 인덱스를 <code class="highlighter-rouge">ORDER BY ... DESC</code>하는 쿼리가 소량의 레코드를 드물게 실행되는 경우라면, <code class="highlighter-rouge">Descending index</code>를 굳이 고려할 필요는 없어 보인다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tab</span> <span class="k">WHERE</span> <span class="n">userid</span><span class="o">=?</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">score</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>예를 들어서 아래와 같은 쿼리인 경우, 아래 2가지 인덱스 모두 적절한 선택이 될 수 있다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">-</span> <span class="n">Ascending</span> <span class="k">index</span>  <span class="p">:</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">userid</span> <span class="k">ASC</span><span class="p">,</span> <span class="n">score</span> <span class="k">ASC</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">Descending</span> <span class="k">index</span> <span class="p">:</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">userid</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">score</span> <span class="k">DESC</span><span class="p">)</span>
</code></pre></div></div>

<p>하지만 위 쿼리가 조금 더 많은 레코드를 빈번하게 실행된다면, <code class="highlighter-rouge">Ascending index</code>보다는 <code class="highlighter-rouge">Descending index</code>가 더 효율적이라고 볼 수 있다. 또한 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목 지점이 될 것으로 예상된다면, 적절히 <code class="highlighter-rouge">Descending index</code>를 생성하는 것이 경합 감소에 도움이 될 것으로 보인다.</p>

<blockquote>
  <p>물론 ASC와 DESC 정렬을 혼합해서 동시에 사용하는 쿼리라면, 당연히 ASC와 DESC를 섞어서 인덱스를 생성해야 하므로, 고민할 필요 없이 쿼리의 정렬 조건에 맞게 인덱스를 생성하면 될 것으로 보인다.</p>
</blockquote>

<p>그리고 <code class="highlighter-rouge">Ascending index</code>와 <code class="highlighter-rouge">Descending index</code>의 선택은 MySQL 서버가 CPU Bound로 쿼리를 처리할 때의 이야기이다. 만약 MySQL 서버가 데이터를 읽기 위해서 매번 Disk를 읽어야 한다면, <code class="highlighter-rouge">Ascending index</code>나 <code class="highlighter-rouge">Descending index</code>의 구조적 장단점은 Disk 반응 속도(Latency)에 이미 상쇄되어 버리기 때문에 그다지 쿼리 처리상 성능 영향 요소가 아니라고 볼 수 있다.</p>

  </div><a class="u-url" href="/2018/06/19/AscendingAndDescendingIndex/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
