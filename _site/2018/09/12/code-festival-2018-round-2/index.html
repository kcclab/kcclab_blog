<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>코드 페스티벌 2018 본선 이야기 | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="코드 페스티벌 2018 본선 이야기" />
<meta name="author" content="lance.moon" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="2018 코드 페스티벌, 뜨거운 열기와 함께 본선 시작!" />
<meta property="og:description" content="2018 코드 페스티벌, 뜨거운 열기와 함께 본선 시작!" />
<link rel="canonical" href="http://localhost:4000/2018/09/12/code-festival-2018-round-2/" />
<meta property="og:url" content="http://localhost:4000/2018/09/12/code-festival-2018-round-2/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:image" content="http://localhost:4000/files/covers/code-festival-2018-round-2.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-12T17:00:00+09:00" />
<script type="application/ld+json">
{"datePublished":"2018-09-12T17:00:00+09:00","dateModified":"2018-09-12T17:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/09/12/code-festival-2018-round-2/"},"url":"http://localhost:4000/2018/09/12/code-festival-2018-round-2/","image":"http://localhost:4000/files/covers/code-festival-2018-round-2.jpg","author":{"@type":"Person","name":"lance.moon"},"description":"2018 코드 페스티벌, 뜨거운 열기와 함께 본선 시작!","@type":"BlogPosting","headline":"코드 페스티벌 2018 본선 이야기","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Your awesome title</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        <!--
            my_page.autogen is populated by the pagination logic for all pages
                            that are automatically created by the gem. Check for non-existence to exclude pagination pages from site.pages iterators
          -->
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/index.html">Your awesome title</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">코드 페스티벌 2018 본선 이야기</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-09-12T17:00:00+09:00" itemprop="datePublished">Sep 12, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">lance.moon</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="2018-코드-페스티벌-뜨거운-열기와-함께-본선-시작">2018 코드 페스티벌, 뜨거운 열기와 함께 본선 시작!</h2>

<p>지난 8월 25일 토요일, 카카오 코드 페스티벌 오프라인 본선이 진행됐습니다. 예선에서의 엄청난 경쟁률을 뚫고 당당히 본선에 진출한 64명의 실력자들이 함께 했는데요. 작년과는 다르게 카카오 판교 오피스에서 행사를 개최하여 더 뜻깊은 자리가 되었던 것 같습니다.</p>

<p><a href="https://brunch.co.kr/@andkakao/67" target="_blank">▶ 행사 후기가 궁금하시다면?</a></p>

<p>그럼 본선에 출제되었던 문제와 해법을 알아보도록 하겠습니다.</p>

<h2 id="문제-설명-및-풀이">문제 설명 및 풀이</h2>

<h3 id="승부-예측">승부 예측</h3>

<ul>
  <li>제출자 62명</li>
  <li>정답자 62명</li>
  <li><a href="https://www.acmicpc.net/problem/15997" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>서로 다른 결과의 경우의 수가 총 3<sup>6</sup> 가지임을 알 수 있습니다. 그러므로 모든 경우를 고려하는 완전 탐색 풀이를 구현하면 됩니다. 
특정 경우에서 동점자가 발생하는 경우가 존재하기 때문에, 동점자가 발생하는 모든 경우를 유의할 필요가 있습니다.</p>

<h3 id="카카오머니">카카오머니</h3>

<ul>
  <li>제출자 64명</li>
  <li>정답자 59명</li>
  <li><a href="https://www.acmicpc.net/problem/15998" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>모순이 없다고 가정하고, <code class="highlighter-rouge">M</code> 을 구해 봅시다. 편의상 b<sub>0</sub> = 0 으로 둔다면, <code class="highlighter-rouge">i</code> (1 ≤ i ≤ n)번째 로그에서 카카오머니 잔고의 변화량은 b<sub>i</sub> - b<sub>i-1</sub> 입니다.</p>

<p>만약 b<sub>i</sub> - b<sub>i-1</sub> = a<sub>i</sub>라면, <code class="highlighter-rouge">i</code> 번째 로그가 입금인지 출금인지의 여부와 관계없이, 카카오머니 잔고가 a<sub>i</sub> 만큼 변하여 제대로 기록된 것입니다.</p>

<p>하지만, 만약 b<sub>i</sub> - b<sub>i-1</sub> ≠ a<sub>i</sub> 라면, 카카오머니 잔고가 부족하여 통장에서 돈을 가져왔을 것입니다. (이 외의 방법이 없습니다.)</p>

<p>통장에서 가져온 금액은 b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 원입니다. 
문제의 지문에서, 통장에서 돈을 가져올 때에는 <code class="highlighter-rouge">M</code> 원씩을 여러 번 가져오므로, b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 이 <code class="highlighter-rouge">M</code> 의 배수여야 한다는 조건을 얻을 수 있습니다. 
또한, 최종 잔고는 <code class="highlighter-rouge">M</code> 원 미만이므로, b<sub>i</sub> &lt; <code class="highlighter-rouge">M</code> 이라는 조건도 얻을 수 있습니다.</p>

<p>위의 관찰 중 첫 번째 조건을 종합해 보면, <code class="highlighter-rouge">M</code> 으로 가능한 수들은 b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 들의 공약수임을 알 수 있습니다. 
이들 중 두 번째 조건을 만족하려면, <code class="highlighter-rouge">M</code> 이 크면 클수록 좋다는 것을 알 수 있습니다.</p>

<p>따라서, b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 들의 최대공약수를 구한 뒤, 이것을 <code class="highlighter-rouge">M</code> 으로 놓고, 주어진 로그대로 입출금을 해보면서 모순이 없는지 확인하면 됩니다.</p>

<h3 id="뒤집기">뒤집기</h3>

<ul>
  <li>제출자 61명</li>
  <li>정답자 60명</li>
  <li><a href="https://www.acmicpc.net/problem/15999" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>문제를 잘 관찰해 보면, 인접한 두 격자의 색이 다른 경우 두 격자의 현재 상태는 초기 상태와 같다는 성질을 발견할 수 있습니다.</p>

<p>증명) 인접한 두 격자의 현재 상태가 <code class="highlighter-rouge">BW</code> 일 때, 원래 <code class="highlighter-rouge">WW</code> 거나 <code class="highlighter-rouge">BB</code> 였다면, 두 격자는 연결되어 있으므로 현재 상태와 같이 달라지는 경우는 발생하지 않습니다. 
원래 <code class="highlighter-rouge">WB</code> 였다면 상태가 바뀔 때 <code class="highlighter-rouge">BW</code> 로 한 번에 바뀔 수 없고, <code class="highlighter-rouge">WW</code> 또는 <code class="highlighter-rouge">BB</code> 를 거쳐야 하므로 불가능합니다. 따라서 초기 상태가 <code class="highlighter-rouge">BW</code> 였음을 알 수 있습니다.</p>

<p>인접한 격자 중 자신과 색이 다른 것이 존재하는 격자들의 경우 위 성질에 의해 색이 정해지고, 그 외의 격자들은 초기 상태에 아무렇게나 칠해져 있어도 현재 상태로 만들 수 있음을 알 수 있습니다. 
(연결된 컴포넌트들의 경계선에 있는 부분은 색이 정해 지므로, 내부는 아무렇게나 칠해져 있어도 경계선과 동일하게 만들 수 있습니다.)</p>

<p>따라서, 가능한 초기 상태의 수는 2<sup>(색이 정해지지 않은 격자의 수)</sup> 가 됩니다.</p>

<h3 id="섬">섬</h3>

<ul>
  <li>제출자 53명</li>
  <li>정답자 22명</li>
  <li><a href="https://www.acmicpc.net/problem/16000" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>튜브는 연료를 구하러 망망대해로 나가고 싶으나, 사냥꾼이 어떠한 섬을 점거했을 때 길이 막힐 것이 두려워 걱정하고 있습니다. 튜브는 현재 위치에서 안전하게 망망대해로 나갈 수 있을까요?</p>

<p>이 문제는 풀이의 방향이 크게 두 갈래로 나뉩니다. 하나는 출제진이 의도하였던 풀이이고, 하나는 출제진이 예상하지 못했던 방향의 풀이입니다. 첫 번째 풀이를 중심으로 설명하나, 두 번째 풀이에 대해서도 간단히 짚고 넘어가겠습니다.</p>

<h4 id="의도된-풀이--그래프의-절점">의도된 풀이 : 그래프의 절점</h4>

<p>문제를 다시 요약해 보겠습니다. 우리는 튜브가 도착한 각각의 섬 <code class="highlighter-rouge">v</code> 에 대해서, <code class="highlighter-rouge">v</code> 와 다른 섬 <code class="highlighter-rouge">w</code> 중, <code class="highlighter-rouge">w</code> 에 사냥꾼이 있을 때 <code class="highlighter-rouge">v</code> 에서 최외곽으로 갈 수 있는 경로가 없어지는 <code class="highlighter-rouge">w</code> 가 존재하는가가 궁금한 것입니다. 
결국에는 “경로” 와 “섬” 에 대한 이야기니, 그래프에 풀어놓고 생각해보면 편리하게 문제를 해결할 수 있습니다.</p>

<p>그래프에 있는 모든 4방향으로 인접한 육지와 바다를 Flood-Fill 로 하나의 정점으로 묶어줍시다. 이제 각각의 정점은 “섬” 이거나 “바다” 로 분류될 수 있습니다. “섬” 과 “바다” 가 맞닿아 있으면 간선을 이어줍시다. 
최외곽의 바다를 1번 정점이라고 하면, 우리가 풀고자 하는 문제는 다음과 같습니다.</p>

<ul>
  <li>그래프 <code class="highlighter-rouge">G</code> 와 튜브가 도착한 각각의 섬 정점 <code class="highlighter-rouge">v</code> 에 대해, <code class="highlighter-rouge">w</code> ≠ <code class="highlighter-rouge">v</code> 가 존재하여, <code class="highlighter-rouge">G</code> 에서 <code class="highlighter-rouge">w</code> 를 제거했을 때 <code class="highlighter-rouge">1</code> 번 정점과 <code class="highlighter-rouge">v</code> 번 정점을 잇는 경로가 존재하지 않는다.</li>
</ul>

<p>왠지 익숙한 느낌이 들지 않나요? 그래프에서 정점 하나를 제거했을 때 경로가 사라지는 형태의 문제이니, “절점”의 개념을 활용할 수 있다고 생각할 수 있습니다. 
그래프에서 어떠한 정점을 제거하였을 때, 컴포넌트의 개수가 증가하는 정점들을 “절점” 이라고 부릅니다. 절점에 대한 자세한 설명은 지면상 생략하겠으나, 어떠한 정점이 절점인지 아닌지를 판별하는 것은 선형 시간에 가능합니다.</p>

<p>절점 개념을 도입하면, 문제는 다음과 같이 변합니다.</p>

<ul>
  <li>모든 섬 <code class="highlighter-rouge">v</code> 에 대해서, “절점인 섬” 을 지나지 않고 <code class="highlighter-rouge">1</code> 번 정점에서 <code class="highlighter-rouge">v</code> 번 정점을 방문할 수 있는지 아닌지를 판별하여라.</li>
</ul>

<p>이는 절점을 구하는 알고리즘을 조금만 응용하면 됩니다. 
1번 정점에서 DFS 를 시작했을 때, 어떠한 점이 절점이면, 해당 점을 거쳐야만 1번 정점으로 갈 수 있는 점들의 집합이 DFS Tree 상의 서브트리로 표현이 됩니다. 
이는 문제가 “서브트리에 있는 정점에 대해서 마킹을 하시오” 의 형태로 환원이 된다는 것을 의미합니다. 
서브트리에 있는 정점은 Euler Tour 번호에서 연속된 구간을 이루기 때문에, 구간에 대한 마킹으로 변환할 수 있으며, 이는 변화값 배열을 사용해서 해결할 수 있습니다.</p>

<h4 id="다른-풀이">다른 풀이</h4>

<p>입력이 결국에는 평면 상의 격자의 모습임을 상기해 보면, 사냥꾼이 점령하고 있는 섬 안에 “둘러싸인” 섬들은 위험한 섬이 된다는 것을 알 수 있습니다. 
즉, 각각의 섬에 대해서 그 섬이 “둘러싸고” 있는 섬들이 무엇인지를 알면 문제를 해결하는 데 조금 더 가까워질 수 있습니다. 둘러싸고 있는 영역을 Flood-Fill 해 주면 되기 때문입니다.</p>

<p>다른 풀이는 이 “둘러싸고 있는 영역” 을 효율적으로 구하는 데 초점을 맞춥니다. 
각각의 섬에 대해서 Flood-Fill 로 해당 섬의 영역을 구해주고, 영역의 빈자리를 찾아낸 후, 해당 빈자리를 다시 Flood-Fill 로 구해주는 것이죠.</p>

<p>직관적으로는 이 부분이 매우 자명하나, 이를 알고리즘으로 옮기는 것은 또 다른 난이도입니다. 여기부터는 출제진도 말을 아끼겠습니다 :D
위 방법은 절점과 같은 고급 개념이 필요하지 않은 알고리즘이지만, 이러한 부분에서의 난이도가 상당히 있었는지, 초반에 이 문제를 빠르게 푼 대부분의 참가자들은 절점 알고리즘을 사용하였습니다.</p>

<h3 id="보물-상자-열기">보물 상자 열기</h3>

<ul>
  <li>제출자 18명</li>
  <li>정답자 12명</li>
  <li><a href="https://www.acmicpc.net/problem/16001" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>먼저, 초기 상태가 회문인 경우에는 답이 모두 0입니다.
그렇지 않은 경우, 주어진 문자열을 <code class="highlighter-rouge">S[1~N]</code> 이라 할 때, <code class="highlighter-rouge">S[i]</code> 가 <code class="highlighter-rouge">S[N+1-i]</code> 와 다른 최소의 <code class="highlighter-rouge">i</code> 를 <code class="highlighter-rouge">b</code> 라 하고, <code class="highlighter-rouge">e = N-b+1</code> 로 두면 주어진 문자열을 회문으로 만들기 위해서는 <code class="highlighter-rouge">b</code> 번째 석판이나 <code class="highlighter-rouge">e</code> 번째 석판을 교체해야 한다는 것을 알 수 있습니다.</p>

<p>또한 <code class="highlighter-rouge">[b, e]</code> 구간 밖에서는 석판을 교체할 이유가 없으므로 시작 위치가 <code class="highlighter-rouge">i</code> 일 때 소모해야 하는 체력을 <code class="highlighter-rouge">H[i]</code> 라 하면,</p>

<ul>
  <li><code class="highlighter-rouge">i</code> &lt; <code class="highlighter-rouge">b</code> 인 경우 H[i] = H[b] + (b-i) * c</li>
  <li><code class="highlighter-rouge">i</code> &gt; <code class="highlighter-rouge">e</code> 인 경우 H[i] = H[e] + (i-e) * c</li>
</ul>

<p>가 되고 <code class="highlighter-rouge">S[b~e]</code> 에 대해서만 문제를 해결하면 됩니다. <code class="highlighter-rouge">b</code> 와 <code class="highlighter-rouge">e</code> 중 석판 <code class="highlighter-rouge">b</code> 를 교체하는 경우를 생각해 보면 시작 위치가 <code class="highlighter-rouge">x</code> 번째 석판일 때 가능한 경로를 다음과 같은 2가지로 분류할 수 있습니다.</p>

<ul>
  <li>x-&gt;r-&gt;b  (x에서 오른쪽으로 갔다가 왼쪽으로 이동하여 b로 가는 경우)</li>
  <li>x-&gt;b-&gt;r  (x에서 왼쪽으로 이동하여 b로 갔다가 오른쪽으로 가는 경우)</li>
</ul>

<p>두 경우 모두 <code class="highlighter-rouge">[b, r]</code> 의 석판만 교체하여 문자열을 회문으로 만들 수 있어야 가능하고, 또한 <code class="highlighter-rouge">[b, r]</code> 에 회문에서 서로 대응되는 두 석판이 모두 포함되는 경우 교체 시 드는 체력이 작은 쪽을 고르는 것이 항상 이득입니다.</p>

<p>모든 <code class="highlighter-rouge">r</code> 에 대해 <code class="highlighter-rouge">[b, r]</code> 구간을 방문할 때 회문을 만들기 위해 석판을 교체하는 데 드는 체력을 배열 <code class="highlighter-rouge">P[]</code> 에 미리 저장해 놓을 수 있습니다. 
그러면 <code class="highlighter-rouge">x</code> 가 주어졌을 때 <code class="highlighter-rouge">x</code> &lt;= <code class="highlighter-rouge">r</code> 인 모든 <code class="highlighter-rouge">r</code> 에 대해 <code class="highlighter-rouge">P[r] + (r-x) + (r-b)</code> 의 최솟값이 <code class="highlighter-rouge">x-&gt;r-&gt;b</code> 의 경로 중 최적인 값이고, <code class="highlighter-rouge">P[r] + (x-b) + (r-b)</code> 의 최솟값이 <code class="highlighter-rouge">x-&gt;b-&gt;r</code> 의 경로 중 최적인 값입니다. 
이는 <code class="highlighter-rouge">x</code> 를 <code class="highlighter-rouge">e</code> 부터 시작하여 왼쪽으로 한 칸씩 밀면서 계산하면 모든 <code class="highlighter-rouge">x</code> 에 대해서 O(N) 시간에 계산할 수 있으므로 석판 <code class="highlighter-rouge">b</code> 를 교체하는 경우에 소모해야 하는 최소 체력을 O(N) 시간에 계산할 수 있습니다. 
석판 <code class="highlighter-rouge">e</code> 를 교체하는 경우도 대칭적으로 생각하면 마찬가지 방법으로 가능합니다.</p>

<p>따라서 선형 시간에 문제를 해결할 수 있습니다.</p>

<h3 id="조용한-생활관-만들기">조용한 생활관 만들기</h3>

<ul>
  <li>제출자 7명</li>
  <li>정답자 0명</li>
  <li><a href="https://www.acmicpc.net/problem/16002" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>먼저, Union 마법을 사용했을 때 사용하기 전보다 더 시끄러워지는 경우는 없습니다. 
처음은 directed rooted tree 형태의 그래프이고, 최종 상태는 Union 마법을 더 이상 쓸 수 없는 상태여야 하므로 모든 도로의 끝점은 트리의 leaf 일 것입니다. 
이 점에 착안하여 생각해보면 이 문제는 directed rooted tree 의 edge 들을, leaf 를 끝점으로 하는 여러 경로들로 나누어 각 경로의 시작점과 끝점에 있는 건물의 사람 수의 곱을 최소로 만드는 문제입니다. 
즉, 건물 <code class="highlighter-rouge">i</code> 에 사는 사람의 수를 <code class="highlighter-rouge">C[i]</code> 라 할 때, 최종 상태의 모든 경로 <code class="highlighter-rouge">u-&gt;v</code> 에 대해 <code class="highlighter-rouge">C[u]*C[v]</code> 의 합을 최소화하면 됩니다.</p>

<p>처음에 주어진 directed rooted tree 에서, root 가 아닌 노드 <code class="highlighter-rouge">u</code> 를 생각해봅시다. 또한, <code class="highlighter-rouge">u</code> 를 root 로 하는 subtree 를 subtree(u) 라고 합시다. 
<code class="highlighter-rouge">u</code> 의 부모에서 <code class="highlighter-rouge">u</code> 로 들어오는 간선이 있으므로, 최종 상태에는 <code class="highlighter-rouge">u</code> 의 조상 중 하나에서 subtree(u)에 포함되는 leaf 로 가는 경로가 하나 있을 것이고, 그 경로에 포함되지 않는 subtree(u)의 edge 들은 subtree(u) 내부의 경로가 될 것입니다.</p>

<p>결론적으로, subtree(u) 내부의 edge 들이 최종적으로 어떤 경로에 포함될지 결정된다면, 외부에 영향을 끼치는 요소는 <code class="highlighter-rouge">u</code> 의 조상 중 하나와 연결될 leaf 의 건물에 있는 사람 수 뿐입니다. 
따라서, 다음과 같은 다이나믹 프로그래밍을 생각할 수 있습니다.</p>

<ul>
  <li>D[u][l] : <code class="highlighter-rouge">u</code> 의 조상 중 하나와 연결되는 leaf 가 <code class="highlighter-rouge">l</code> 일 때, <code class="highlighter-rouge">u</code> 내부 경로들에서 만들어지는 시끄러운 정도의 최솟값</li>
</ul>

<p>점화식은 다음과 같습니다.</p>

<ul>
  <li>u = l : D[u][l] = 0</li>
  <li>u ≠ l : <code class="highlighter-rouge">u</code> 의 자식 중 <code class="highlighter-rouge">x</code> 가 <code class="highlighter-rouge">l</code> ∈ subtree(x)을 만족할 때,<br />
D[u][l] = D[x][l] + (<code class="highlighter-rouge">u</code> 의 <code class="highlighter-rouge">x</code> 가 아닌 모든 자식 <code class="highlighter-rouge">v</code> 에 대해, (D[v][l’]+C[u]C[l’]) 의 최솟값들의 합<br />
(단, <code class="highlighter-rouge">l'</code> 은 subtree(v)의 leaf))</li>
</ul>

<p>각 자식 노드 <code class="highlighter-rouge">v</code> 에 대해 <code class="highlighter-rouge">D[v][l'] + C[u]C[l']</code> 이 최소가 되는 <code class="highlighter-rouge">l'</code> 을 미리 구해놓을 수 있으므로, 시간 복잡도는 각 노드 <code class="highlighter-rouge">u</code> 에 대해 subtree(u)의 leaf <code class="highlighter-rouge">l</code> 을 선택하는 경우의 수인 O(N<sup>2</sup>)가 됩니다.
위 다이나믹 프로그래밍은 O(N<sup>2</sup>)의 시간 복잡도를 가지므로, 시간 초과가 발생하게 됩니다. 이를 줄이기 위해서는 한 가지 관찰이 필요합니다.</p>

<p>subtree(u)의 모든 leaf <code class="highlighter-rouge">l</code> 에 대해, 좌표평면 상에서 <code class="highlighter-rouge">y = C[l] * x + D[u][l]</code> 라는 직선을 그었다고 생각해봅시다. 0 이상의 모든 <code class="highlighter-rouge">x</code> 에 대해 그 <code class="highlighter-rouge">x</code> 에서 함숫값이 최소가 되는 직선을 구했다고 합시다. 
만약 어떤 <code class="highlighter-rouge">x</code> 에서도 함숫값이 최소가 되지 않는 직선이 있다면, 그 직선은 최적해를 구하는 데에 있어 쓸모가 없습니다. 그 leaf 가 <code class="highlighter-rouge">u</code> 의 어느 조상과 연결되든 간에 더 좋은 방법이 존재하기 때문입니다. 
따라서 정점 <code class="highlighter-rouge">u</code> 에 대해 subtree(u)의 모든 leaf 에 대한 값을 저장할 필요가 없고, 위에서 설명한 직선들의 아래쪽 convex hull 만을 들고 있으면 충분합니다.</p>

<p>앞에서 설명한 DP를 이 convex hull 을 이용해서 할 수 있는데, 먼저 <code class="highlighter-rouge">u</code> 의 모든 자식 <code class="highlighter-rouge">v</code> 에 대해 <code class="highlighter-rouge">D[v][l'] + C[u]C[l']</code> 의 최솟값은 <code class="highlighter-rouge">v</code> 의 아래쪽 convex hull 이 <code class="highlighter-rouge">x = C[u]</code> 와 만나는 부분임을 쉽게 알 수 있습니다. 
따라서 이를 미리 계산해 놓을 수 있습니다. 또한 <code class="highlighter-rouge">u</code> 의 자식 <code class="highlighter-rouge">v</code> 에 대해 subtree(v)에 포함되는 leaf 가 <code class="highlighter-rouge">u</code> 의 조상과 연결되는 경우는 <code class="highlighter-rouge">v</code> 의 convex hull 이 일정 크기만큼(정확히는 <code class="highlighter-rouge">v</code> 가 아닌 모든 자식 <code class="highlighter-rouge">c</code> 에서 <code class="highlighter-rouge">D[c][l'] + C[c]C[l']</code> 의 최솟값의 합만큼) 위로 올라간 것임을 알 수 있습니다. 
따라서, 자식들에 저장된 convex hull 들을 y 축 방향으로 평행 이동시킨 후에 모두 합쳐서 convex hull 을 다시 구할 수 있다면 앞서 설명한 DP 와 정확하게 같은 것을 할 수 있는 것입니다.</p>

<p>먼저 set 을 이용해 Dynamic Convex Hull 자료구조를 만들면 O(log N) 시간에 직선을 추가하는 연산을 수행할 수 있고, 
어떤 x 좌표가 주어졌을 때 convex hull 에서 해당하는 y 좌표를 이분 탐색을 이용해 O(log<sup>2</sup>N) 시간에 찾을 수 있습니다.</p>

<p>y축 방향으로 얼마만큼 평행이동되었는지는 따로 저장해 놓으면 쉽게 관리할 수 있습니다.
x 좌표가 주어졌을 때 convex hull 에서 y 좌표를 찾는 연산은 <code class="highlighter-rouge">D[v][l'] + C[u]C[l']</code> 의 최솟값을 찾을 때 사용하므로 총 O(N)번 쓰게 되어 여기서 시간 복잡도 O(N log<sup>2</sup>N)가 발생합니다. 
자식들의 convex hull 들을 합쳐야 하는데, 자식들 중 가장 직선이 많은 convex hull 에 다른 자식들의 convex hull 의 직선을 삽입하는 small-to-large 방식으로 이를 해결할 수 있습니다. 
여기에서 직선 삽입은 Heavy-Light Decomposition 과 같은 원리로 최대 O(N logN)번만 수행됩니다. 따라서, 여기서 발생하는 시간 복잡도는 O(N log<sup>2</sup>N)입니다.</p>

<p>따라서, 총 시간 복잡도 O(N log<sup>2</sup>N)에 문제를 해결할 수 있습니다.</p>

<h3 id="자석-장난감">자석 장난감</h3>

<ul>
  <li>제출자 8명</li>
  <li>정답자 1명</li>
  <li><a href="https://www.acmicpc.net/problem/16003" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>이 문제는 그래프에서 규칙에 따라 모든 노드를 제거할 수 있는지 확인하는 문제입니다.<br />
제거하는 규칙은, 어떤 노드 <code class="highlighter-rouge">X</code> 가 제거될 때 그 노드에 연결된 다른 모든 노드 <code class="highlighter-rouge">A, B, …, D</code> 가 서로 모두 연결되어 있어야 한다는 것입니다. 
이 조건에서 <code class="highlighter-rouge">X, A, B, …, D</code> 는 하나의 Clique(모든 노드 쌍이 연결된 부분 그래프)를 이룬다는 것을 알 수 있습니다. 
그래프의 한 상태에서 제거될 조건을 만족하는 노드는 어느 것을 먼저 제거하더라도 상관없다는 것을 짐작할 수 있고 증명할 수 있습니다. 
하지만, 이렇게 조건을 하나하나 확인하면서 제거할 수 있는 노드를 찾아 나가며 진행하는 것은 매우 느린 방법이 됩니다.</p>

<p>빠른 방법 중 하나는 노드를 제거하는 “특정한 순서”를 찾고, 그 순서에 따라서 노드를 제거했을 때 조건을 만족하면서 모든 노드를 제거할 수 있음을 확인하는 것입니다. 
이 “특정한 순서”는, 만약 모든 노드를 제거할 수 있는 순서가 하나라도 있다면 반드시 모든 노드를 제거할 수 있는 순서가 된다는 성질을 가집니다. 
모든 노드를 제거할 수 있는 그래프는 Clique 들이 서로 노드를 공유하는 모양으로만 구성되어 있어야 한다는 것을 어렵지 않게 짐작할 수 있고 증명할 수 있습니다.</p>

<p>비교적 단순하게 두 개의 Clique <code class="highlighter-rouge">P</code> 와 <code class="highlighter-rouge">Q</code> 가 일부 노드를 공유하고 있는 그래프로 설명해 보겠습니다. 
이 그래프는 모든 노드를 제거하는 것이 가능한 그래프임이 당연합니다. 노드들의 집합 <code class="highlighter-rouge">P-Q</code>, <code class="highlighter-rouge">Q-P</code>, <code class="highlighter-rouge">P∩Q</code> 를 생각해 봅시다. 
<code class="highlighter-rouge">P-Q</code> 나 <code class="highlighter-rouge">Q-P</code> 에 있는 노드가 가장 먼저 제거되는 것은 가능하지만, <code class="highlighter-rouge">P∩Q</code> 에 있는 노드가 가장 먼저 제거되는 것은 불가능합니다. 
<code class="highlighter-rouge">P-Q</code> 나 <code class="highlighter-rouge">Q-P</code> 중 한 집합이라도 모두 제거되어야 <code class="highlighter-rouge">P∩Q</code> 에 있는 노드가 제거될 수 있음을 알 수 있습니다.</p>

<p>이제, 아무 노드에서나 시작해서 그래프를 탐색하면서 방문하는 순서대로 노드들을 출력합니다. 
노드가 출력되면 노드에 연결된 다른 노드들에 모두 카운터를 1 증가시키는 연산을 합니다. 카운터 값이 큰 노드부터 무조건 다음에 출력합니다.</p>

<p>만약 이 탐색이 <code class="highlighter-rouge">P-Q</code>(혹은 <code class="highlighter-rouge">Q-P</code>) 에 있는 노드에서 시작된다면 <code class="highlighter-rouge">P</code>(혹은 <code class="highlighter-rouge">Q</code>)가 모두 출력된 다음에야 나머지 노드가 출력될 수 있습니다.<br />
만약 이 탐색이 <code class="highlighter-rouge">P∩Q</code> 에 있는 노드에서 시작된다면, 탐색이 최초로 <code class="highlighter-rouge">P-Q</code>(혹은 <code class="highlighter-rouge">Q-P</code>) 에 들어가는 순간 <code class="highlighter-rouge">P-Q</code>(혹은 <code class="highlighter-rouge">Q-P</code>) 에 있는 노드가 모두 출력된 다음에야 <code class="highlighter-rouge">Q-P</code>(혹은 <code class="highlighter-rouge">P-Q</code>) 에 있는 노드가 출력됨을 알 수 있습니다.</p>

<p>모든 경우를 증명하는 것은 복잡하지만 이런 방식으로 출력하면, 출력의 반대 순서가 반드시 제거 가능한 순서가 됨을 알 수 있습니다.</p>

<p>특정한 하나의 순서를 찾았으면 이 순서가 규칙을 지키는 제거 순서인지를 확인해야 합니다. 
제거 과정에서 매번 규칙을 전부 확인하면 시간이 아주 오래 걸리게 됩니다. 
하지만, 이 과정을 살펴보면 동일한 노드 쌍의 연결 관계를 반복적으로 확인하고 있음을 알 수 있습니다. 
동적 프로그래밍과 비슷한 방법으로 반복적으로 확인하는 것을 한 번만 확인하도록 줄여서 빠른 시간에 규칙을 지키는지 확인하는 것이 가능합니다.</p>

<p>이러한 두 가지 과정을 거쳐서 O((N+M)logN) 시간 알고리즘을 구현할 수 있습니다.<br />
대회에서는 O(N sqrt(N)) 정도 알고리즘도 통과할 수 있는 수준으로 채점 데이터가 만들어졌습니다.</p>

<h3 id="헬리콥터">헬리콥터</h3>

<ul>
  <li>제출자 4명</li>
  <li>정답자 0명</li>
  <li><a href="https://www.acmicpc.net/problem/16004" target="_blank">문제 풀러 가기</a></li>
</ul>

<p>이 문제는 직교 다각형 형태로 주어진 영역을 왼쪽에서 오른쪽으로 비행할 때 단 한 번의 사선 방향을 제외하고는 모두 수직이나 수평으로만 움직일 수 있다고 가정하고 가장 짧은 거리를 찾는 문제입니다. 
이 문제의 답을 구현하는 것은 매우 어렵지만 아이디어를 설명하는 것은 비교적 간단합니다.</p>

<p>우선, 사선 방향 없이 수직 수평으로만 움직이는 경로를 생각해 봅시다. 주어진 영역 안에서 그러한 최단 경로는 매우 많습니다. 
최단 경로들을 모두 그렸다고 하면 그려진 경로들은 모여서 하나의 영역을 만들게 됩니다. 이 영역을 “새 영역”이라고 부릅시다. 새 영역을 구하는 것은 O(N) 시간에 가능합니다.</p>

<p>단 한 번의 사선 방향으로의 움직임(사선 성분)에 대해 다음 세 가지를 확인할 수 있습니다.</p>

<ul>
  <li>(1) 최적인 사선 성분은 새 영역 안에 있다.</li>
  <li>(2) 최적인 사선 성분은 새 영역의 경계를 끝점으로 가진다.</li>
  <li>(3) 최적인 사선 성분은 새 영역의 꼭짓점과 교차한다.</li>
</ul>

<p>이 세 가지 성질에서 다음과 같은 알고리즘을 만들 수 있습니다.<br />
새 영역의 각 꼭짓점에서 그 꼭짓점에 걸치면서 그 꼭짓점에서 보이는 영역의 경계 위의 두 점을 잇는 모든 선분을 확인합니다. 
각 꼭짓점에서는 O(N)개의 다른 꼭짓점이 보입니다. 선분들 중 적어도 한쪽이 꼭짓점인 것들은 따라서 O(N)개가 됩니다. 이들 중 최적인 것이 있다면 쉽게 확인할 수 있습니다. 
이들 중 최적인 것이 없다면 앞에서 확인한 선분들 사이를 회전시켜 가면서 최적인 선분을 찾아볼 수 있습니다. 
선분을 회전할 때 사선이 만들어 내는 이익은 증가나 감소를 최대 한 번 바꿀 수 있다는 것을 알아낼 수 있어 삼분 탐색으로 충분한 오차 이내까지 선분을 찾아 내려갈 수 있습니다.</p>

<p>이러한 방법으로 O(N<sup>2</sup> logN * log10<sup>9</sup>) 시간이 걸리는 알고리즘을 만들 수 있습니다.<br />
대회에서는 O(N<sup>3</sup>) 정도 되는 알고리즘도 통과할 수 있는 수준으로 채점 데이터가 만들어졌습니다.</p>

<h2 id="결과-발표">결과 발표</h2>

<p>그럼 이제, 코드 페스티벌 본선 결과를 공개합니다! 본선은 예선과 같은 방식으로 채점이 진행되었으며, 1등은 출제된 8문제 중 6문제를 풀어주셨습니다.</p>

<p><a href="http://t1.kakaocdn.net/codefestival/2018-round-2-scoreboard/index.html" target="_blank">▶ 순위표 보러 가기</a></p>

<p>사전에 공지된 대로 우수한 성적을 거둔 상위 31명의 참가자에게 상장 및 상금이 수여되었습니다. 아쉽게 수상권에 들지 못한 분들을 위해 다양한 특별상도 준비했는데요, 수상하신 모든 분들 축하드립니다!</p>

<p>마지막으로 작년에 비해 본선 문제의 난이도가 높다는 피드백이 많았는데요, 그럼에도 불구하고 끝까지 코드 페스티벌에 적극적으로 참여해주신 분들께 감사드립니다.</p>

<p>앞으로 있을 개발자 행사에도 많은 관심 부탁드립니다 :)</p>

  </div><a class="u-url" href="/2018/09/12/code-festival-2018-round-2/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
